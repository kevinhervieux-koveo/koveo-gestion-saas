b90d179c202de1967f0eee5504fef7d9
"use strict";
/**
 * Form Validation Standards Test Suite
 * Simplified tests to ensure all forms follow basic validation principles
 */
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const zod_1 = require("zod");
(0, globals_1.describe)('Form Validation Standards', () => {
    (0, globals_1.describe)('Basic Error Message Requirements', () => {
        (0, globals_1.test)('should require helpful error messages for common field types', () => {
            // Test that our validation templates produce good error messages
            const commonFields = {
                email: zod_1.z.string().email('Please enter a valid email address (example: user@domain.com)'),
                name: zod_1.z.string().min(1, 'Name is required (example: Jean Dupont)'),
                phone: zod_1.z.string().regex(/^(\+1\s?)?(\(\d{3}\)|\d{3})[\s.-]?\d{3}[\s.-]?\d{4}$/, 'Phone number must be a valid North American format (example: (514) 123-4567)').optional(),
                amount: zod_1.z.string().regex(/^\d+(\.\d{1,2})?$/, 'Amount must be a valid number with up to 2 decimal places (example: 125.50)'),
                selection: zod_1.z.string().min(1, 'Please select an option from the dropdown')
            };
            // Test each field type produces helpful error messages
            Object.entries(commonFields).forEach(([fieldType, schema]) => {
                // Test with appropriate invalid input for each field type
                let invalidInput = '';
                switch (fieldType) {
                    case 'email':
                        invalidInput = 'invalid-email';
                        break;
                    case 'phone':
                        invalidInput = '123';
                        break;
                    case 'amount':
                        invalidInput = '123.456';
                        break;
                    default:
                        invalidInput = '';
                }
                const result = schema.safeParse(invalidInput);
                if (!result.success) {
                    const errorMessage = result.error.issues[0].message;
                    // Basic quality checks
                    (0, globals_1.expect)(errorMessage.length).toBeGreaterThan(10);
                    (0, globals_1.expect)(errorMessage).toMatch(/please|must|required|should/i);
                    // Format fields should have examples
                    if (['email', 'phone', 'amount'].includes(fieldType)) {
                        (0, globals_1.expect)(errorMessage).toContain('example:');
                    }
                }
            });
        });
        (0, globals_1.test)('should validate Quebec-specific validation patterns work correctly', () => {
            const quebecValidations = {
                name: zod_1.z.string().regex(/^[a-zA-ZÀ-ÿ\s'-]+$/, 'Name can only contain letters, spaces, apostrophes and hyphens'),
                postalCode: zod_1.z.string().regex(/^[A-Z]\d[A-Z]\s?\d[A-Z]\d$/, 'Postal code must follow Canadian format (example: H1A 1B1)'),
                city: zod_1.z.string().regex(/^[a-zA-ZÀ-ÿ\s'-]+$/, 'City name can only contain letters, spaces, apostrophes and hyphens')
            };
            // Test valid Quebec inputs
            (0, globals_1.expect)(quebecValidations.name.safeParse('Jean-Baptiste').success).toBe(true);
            (0, globals_1.expect)(quebecValidations.name.safeParse('Marie-Ève').success).toBe(true);
            (0, globals_1.expect)(quebecValidations.postalCode.safeParse('H1A 1B1').success).toBe(true);
            (0, globals_1.expect)(quebecValidations.city.safeParse('Montréal').success).toBe(true);
            // Test that error messages are helpful
            const nameResult = quebecValidations.name.safeParse('Name123');
            const postalResult = quebecValidations.postalCode.safeParse('12345');
            (0, globals_1.expect)(nameResult.success).toBe(false);
            (0, globals_1.expect)(postalResult.success).toBe(false);
            if (!nameResult.success) {
                (0, globals_1.expect)(nameResult.error.issues[0].message).toContain('letters, spaces');
            }
            if (!postalResult.success) {
                (0, globals_1.expect)(postalResult.error.issues[0].message).toContain('Canadian format');
                (0, globals_1.expect)(postalResult.error.issues[0].message).toContain('example:');
            }
        });
    });
    (0, globals_1.describe)('Validation Helper Functions', () => {
        (0, globals_1.test)('should provide utility to check error message quality', () => {
            const checkErrorMessageQuality = (message) => {
                return {
                    isDetailed: message.length >= 15,
                    hasGuidance: /please|must|should|required/i.test(message),
                    isNotVague: !/^(invalid|error|wrong|bad)$/i.test(message),
                    hasExample: message.includes('example:')
                };
            };
            // Test good messages
            const goodMessages = [
                'Please enter a valid email address (example: user@domain.com)',
                'Name is required (example: Jean Dupont)',
                'Amount must be a valid number with up to 2 decimal places (example: 125.50)'
            ];
            goodMessages.forEach(message => {
                const quality = checkErrorMessageQuality(message);
                (0, globals_1.expect)(quality.isDetailed).toBe(true);
                (0, globals_1.expect)(quality.hasGuidance).toBe(true);
                (0, globals_1.expect)(quality.isNotVague).toBe(true);
            });
            // Test bad messages
            const badMessages = ['Invalid', 'Required', 'Error'];
            badMessages.forEach(message => {
                const quality = checkErrorMessageQuality(message);
                (0, globals_1.expect)(quality.isDetailed).toBe(false);
                // Note: 'Required' doesn't match the vague pattern, but it's still not ideal
                if (message === 'Invalid' || message === 'Error') {
                    (0, globals_1.expect)(quality.isNotVague).toBe(false);
                }
            });
        });
    });
    (0, globals_1.describe)('Future Form Compliance', () => {
        (0, globals_1.test)('should provide templates for consistent form validation', () => {
            const validationTemplates = {
                email: () => zod_1.z.string().min(1, 'Email address is required').email('Please enter a valid email address (example: user@domain.com)'),
                name: (fieldName, example) => zod_1.z.string().min(1, `${fieldName} is required (example: ${example})`),
                phone: () => zod_1.z.string().regex(/^(\+1\s?)?(\(\d{3}\)|\d{3})[\s.-]?\d{3}[\s.-]?\d{4}$/, 'Phone number must be a valid North American format (example: (514) 123-4567)').optional(),
                amount: () => zod_1.z.string().regex(/^\d+(\.\d{1,2})?$/, 'Amount must be a valid number with up to 2 decimal places (example: 125.50)'),
                selection: (fieldName) => zod_1.z.string().min(1, `Please select ${fieldName} from the dropdown`)
            };
            // Test that templates work correctly
            (0, globals_1.expect)(() => validationTemplates.email().parse('user@domain.com')).not.toThrow();
            (0, globals_1.expect)(() => validationTemplates.name('First name', 'Jean').parse('Jean')).not.toThrow();
            (0, globals_1.expect)(() => validationTemplates.amount().parse('125.50')).not.toThrow();
            // Test that templates produce helpful error messages
            const emailError = validationTemplates.email().safeParse('invalid');
            const nameError = validationTemplates.name('First name', 'Jean').safeParse('');
            (0, globals_1.expect)(emailError.success).toBe(false);
            (0, globals_1.expect)(nameError.success).toBe(false);
        });
    });
    (0, globals_1.describe)('Application Compliance Standards', () => {
        (0, globals_1.test)('should define minimum compliance requirements for all forms', () => {
            const complianceRequirements = {
                errorMessages: {
                    minLength: 15,
                    mustContainGuidance: true,
                    shouldIncludeExamples: true,
                    avoidVagueLanguage: true
                },
                quebecSupport: {
                    frenchCharacters: true,
                    canadianFormats: true,
                    appropriateExamples: true
                },
                accessibility: {
                    dataTestIds: true,
                    properLabels: true,
                    errorAssociation: true
                },
                security: {
                    passwordValidation: true,
                    sensitiveDataProtection: true,
                    confirmationForDestructive: true
                }
            };
            // Validate all requirements are properly defined
            Object.entries(complianceRequirements).forEach(([category, requirements]) => {
                (0, globals_1.expect)(category).toMatch(/errorMessages|quebecSupport|accessibility|security/);
                Object.entries(requirements).forEach(([requirement, value]) => {
                    (0, globals_1.expect)(typeof value === 'boolean' || typeof value === 'number').toBe(true);
                    if (typeof value === 'boolean') {
                        (0, globals_1.expect)(value).toBe(true);
                    }
                });
            });
        });
    });
    (0, globals_1.describe)('Development Workflow Integration', () => {
        (0, globals_1.test)('should provide clear guidelines for form validation implementation', () => {
            const implementationSteps = [
                'Use ValidationTemplates from form-validation-helpers.ts for consistent schemas',
                'Implement React Hook Form with zodResolver for type safety',
                'Use FormLabel, FormControl, FormMessage components for consistent UI',
                'Add data-testid attributes to all interactive elements',
                'Include validation tests for all new forms',
                'Verify Quebec compliance for name and address fields'
            ];
            // Validate implementation steps are comprehensive
            (0, globals_1.expect)(implementationSteps.length).toBeGreaterThanOrEqual(6);
            implementationSteps.forEach(step => {
                (0, globals_1.expect)(step.length).toBeGreaterThan(25);
                (0, globals_1.expect)(step).toMatch(/use|implement|add|include|verify/i);
            });
        });
        (0, globals_1.test)('should establish testing requirements for form validation', () => {
            const testingRequirements = [
                'Test schema validation produces helpful error messages',
                'Test UI displays red labels when validation fails',
                'Test error messages clear when fields become valid',
                'Test accessibility compliance with screen readers',
                'Test Quebec character support in name fields',
                'Test Canadian format validation for postal codes and phone numbers'
            ];
            testingRequirements.forEach(requirement => {
                (0, globals_1.expect)(requirement).toMatch(/test/i);
                (0, globals_1.expect)(requirement.length).toBeGreaterThan(30);
            });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS90ZXN0cy91bml0L2Zvcm0tdmFsaWRhdGlvbi1zdGFuZGFyZHMudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOztBQUdILDJDQUF1RDtBQUR2RCw2QkFBd0I7QUFHeEIsSUFBQSxrQkFBUSxFQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtJQUN6QyxJQUFBLGtCQUFRLEVBQUMsa0NBQWtDLEVBQUUsR0FBRyxFQUFFO1FBQ2hELElBQUEsY0FBSSxFQUFDLDhEQUE4RCxFQUFFLEdBQUcsRUFBRTtZQUN4RSxpRUFBaUU7WUFDakUsTUFBTSxZQUFZLEdBQUc7Z0JBQ25CLEtBQUssRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLCtEQUErRCxDQUFDO2dCQUN4RixJQUFJLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUseUNBQXlDLENBQUM7Z0JBQ2xFLEtBQUssRUFBRSxPQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLHNEQUFzRCxFQUFFLDhFQUE4RSxDQUFDLENBQUMsUUFBUSxFQUFFO2dCQUMxSyxNQUFNLEVBQUUsT0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsRUFBRSw2RUFBNkUsQ0FBQztnQkFDNUgsU0FBUyxFQUFFLE9BQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLDJDQUEyQyxDQUFDO2FBQzFFLENBQUM7WUFFRix1REFBdUQ7WUFDdkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFO2dCQUMzRCwwREFBMEQ7Z0JBQzFELElBQUksWUFBWSxHQUFHLEVBQUUsQ0FBQztnQkFDdEIsUUFBUSxTQUFTLEVBQUUsQ0FBQztvQkFDbEIsS0FBSyxPQUFPO3dCQUNWLFlBQVksR0FBRyxlQUFlLENB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Q2pDLElBQUEsZ0JBQU0sRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUN4QyxJQUFBLGdCQUFNLEVBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7WUFDNUQsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUEsY0FBSSxFQUFDLDJEQUEyRCxFQUFFLEdBQUcsRUFBRTtZQUNyRSxNQUFNLG1CQUFtQixHQUFHO2dCQUMxQix3REFBd0Q7Z0JBQ3hELG1EQUFtRDtnQkFDbkQsb0RBQW9EO2dCQUNwRCxtREFBbUQ7Z0JBQ25ELDhDQUE4QztnQkFDOUMsb0VBQW9FO2FBQ3JFLENBQUM7WUFFRixtQkFBbUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ3hDLElBQUEsZ0JBQU0sRUFBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3JDLElBQUEsZ0JBQU0sRUFBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2pELENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvdGVzdHMvdW5pdC9mb3JtLXZhbGlkYXRpb24tc3RhbmRhcmRzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGb3JtIFZhbGlkYXRpb24gU3RhbmRhcmRzIFRlc3QgU3VpdGVcbiAqIFNpbXBsaWZpZWQgdGVzdHMgdG8gZW5zdXJlIGFsbCBmb3JtcyBmb2xsb3cgYmFzaWMgdmFsaWRhdGlvbiBwcmluY2lwbGVzXG4gKi9cblxuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgeyBkZXNjcmliZSwgdGVzdCwgZXhwZWN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbmRlc2NyaWJlKCdGb3JtIFZhbGlkYXRpb24gU3RhbmRhcmRzJywgKCkgPT4ge1xuICBkZXNjcmliZSgnQmFzaWMgRXJyb3IgTWVzc2FnZSBSZXF1aXJlbWVudHMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHJlcXVpcmUgaGVscGZ1bCBlcnJvciBtZXNzYWdlcyBmb3IgY29tbW9uIGZpZWxkIHR5cGVzJywgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB0aGF0IG91ciB2YWxpZGF0aW9uIHRlbXBsYXRlcyBwcm9kdWNlIGdvb2QgZXJyb3IgbWVzc2FnZXNcbiAgICAgIGNvbnN0IGNvbW1vbkZpZWxkcyA9IHtcbiAgICAgICAgZW1haWw6IHouc3RyaW5nKCkuZW1haWwoJ1BsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MgKGV4YW1wbGU6IHVzZXJAZG9tYWluLmNvbSknKSxcbiAgICAgICAgbmFtZTogei5zdHJpbmcoKS5taW4oMSwgJ05hbWUgaXMgcmVxdWlyZWQgKGV4YW1wbGU6IEplYW4gRHVwb250KScpLFxuICAgICAgICBwaG9uZTogei5zdHJpbmcoKS5yZWdleCgvXihcXCsxXFxzPyk/KFxcKFxcZHszfVxcKXxcXGR7M30pW1xccy4tXT9cXGR7M31bXFxzLi1dP1xcZHs0fSQvLCAnUGhvbmUgbnVtYmVyIG11c3QgYmUgYSB2YWxpZCBOb3J0aCBBbWVyaWNhbiBmb3JtYXQgKGV4YW1wbGU6ICg1MTQpIDEyMy00NTY3KScpLm9wdGlvbmFsKCksXG4gICAgICAgIGFtb3VudDogei5zdHJpbmcoKS5yZWdleCgvXlxcZCsoXFwuXFxkezEsMn0pPyQvLCAnQW1vdW50IG11c3QgYmUgYSB2YWxpZCBudW1iZXIgd2l0aCB1cCB0byAyIGRlY2ltYWwgcGxhY2VzIChleGFtcGxlOiAxMjUuNTApJyksXG4gICAgICAgIHNlbGVjdGlvbjogei5zdHJpbmcoKS5taW4oMSwgJ1BsZWFzZSBzZWxlY3QgYW4gb3B0aW9uIGZyb20gdGhlIGRyb3Bkb3duJylcbiAgICAgIH07XG5cbiAgICAgIC8vIFRlc3QgZWFjaCBmaWVsZCB0eXBlIHByb2R1Y2VzIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXNcbiAgICAgIE9iamVjdC5lbnRyaWVzKGNvbW1vbkZpZWxkcykuZm9yRWFjaCgoW2ZpZWxkVHlwZSwgc2NoZW1hXSkgPT4ge1xuICAgICAgICAvLyBUZXN0IHdpdGggYXBwcm9wcmlhdGUgaW52YWxpZCBpbnB1dCBmb3IgZWFjaCBmaWVsZCB0eXBlXG4gICAgICAgIGxldCBpbnZhbGlkSW5wdXQgPSAnJztcbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlICdlbWFpbCc6XG4gICAgICAgICAgICBpbnZhbGlkSW5wdXQgPSAnaW52YWxpZC1lbWFpbCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwaG9uZSc6XG4gICAgICAgICAgICBpbnZhbGlkSW5wdXQgPSAnMTIzJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ftb3VudCc6XG4gICAgICAgICAgICBpbnZhbGlkSW5wdXQgPSAnMTIzLjQ1Nic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW52YWxpZElucHV0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuc2FmZVBhcnNlKGludmFsaWRJbnB1dCk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXN1bHQuZXJyb3IuaXNzdWVzWzBdLm1lc3NhZ2U7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQmFzaWMgcXVhbGl0eSBjaGVja3NcbiAgICAgICAgICBleHBlY3QoZXJyb3JNZXNzYWdlLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDEwKTtcbiAgICAgICAgICBleHBlY3QoZXJyb3JNZXNzYWdlKS50b01hdGNoKC9wbGVhc2V8bXVzdHxyZXF1aXJlZHxzaG91bGQvaSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9ybWF0IGZpZWxkcyBzaG91bGQgaGF2ZSBleGFtcGxlc1xuICAgICAgICAgIGlmIChbJ2VtYWlsJywgJ3Bob25lJywgJ2Ftb3VudCddLmluY2x1ZGVzKGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIGV4cGVjdChlcnJvck1lc3NhZ2UpLnRvQ29udGFpbignZXhhbXBsZTonKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHZhbGlkYXRlIFF1ZWJlYy1zcGVjaWZpYyB2YWxpZGF0aW9uIHBhdHRlcm5zIHdvcmsgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgcXVlYmVjVmFsaWRhdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IHouc3RyaW5nKCkucmVnZXgoL15bYS16QS1aw4Atw79cXHMnLV0rJC8sICdOYW1lIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgc3BhY2VzLCBhcG9zdHJvcGhlcyBhbmQgaHlwaGVucycpLFxuICAgICAgICBwb3N0YWxDb2RlOiB6LnN0cmluZygpLnJlZ2V4KC9eW0EtWl1cXGRbQS1aXVxccz9cXGRbQS1aXVxcZCQvLCAnUG9zdGFsIGNvZGUgbXVzdCBmb2xsb3cgQ2FuYWRpYW4gZm9ybWF0IChleGFtcGxlOiBIMUEgMUIxKScpLFxuICAgICAgICBjaXR5OiB6LnN0cmluZygpLnJlZ2V4KC9eW2EtekEtWsOALcO/XFxzJy1dKyQvLCAnQ2l0eSBuYW1lIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgc3BhY2VzLCBhcG9zdHJvcGhlcyBhbmQgaHlwaGVucycpXG4gICAgICB9O1xuXG4gICAgICAvLyBUZXN0IHZhbGlkIFF1ZWJlYyBpbnB1dHNcbiAgICAgIGV4cGVjdChxdWViZWNWYWxpZGF0aW9ucy5uYW1lLnNhZmVQYXJzZSgnSmVhbi1CYXB0aXN0ZScpLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocXVlYmVjVmFsaWRhdGlvbnMubmFtZS5zYWZlUGFyc2UoJ01hcmllLcOIdmUnKS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHF1ZWJlY1ZhbGlkYXRpb25zLnBvc3RhbENvZGUuc2FmZVBhcnNlKCdIMUEgMUIxJykuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChxdWViZWNWYWxpZGF0aW9ucy5jaXR5LnNhZmVQYXJzZSgnTW9udHLDqWFsJykuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgLy8gVGVzdCB0aGF0IGVycm9yIG1lc3NhZ2VzIGFyZSBoZWxwZnVsXG4gICAgICBjb25zdCBuYW1lUmVzdWx0ID0gcXVlYmVjVmFsaWRhdGlvbnMubmFtZS5zYWZlUGFyc2UoJ05hbWUxMjMnKTtcbiAgICAgIGNvbnN0IHBvc3RhbFJlc3VsdCA9IHF1ZWJlY1ZhbGlkYXRpb25zLnBvc3RhbENvZGUuc2FmZVBhcnNlKCcxMjM0NScpO1xuXG4gICAgICBleHBlY3QobmFtZVJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChwb3N0YWxSZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG5cbiAgICAgIGlmICghbmFtZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChuYW1lUmVzdWx0LmVycm9yLmlzc3Vlc1swXS5tZXNzYWdlKS50b0NvbnRhaW4oJ2xldHRlcnMsIHNwYWNlcycpO1xuICAgICAgfVxuICAgICAgaWYgKCFwb3N0YWxSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocG9zdGFsUmVzdWx0LmVycm9yLmlzc3Vlc1swXS5tZXNzYWdlKS50b0NvbnRhaW4oJ0NhbmFkaWFuIGZvcm1hdCcpO1xuICAgICAgICBleHBlY3QocG9zdGFsUmVzdWx0LmVycm9yLmlzc3Vlc1swXS5tZXNzYWdlKS50b0NvbnRhaW4oJ2V4YW1wbGU6Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdWYWxpZGF0aW9uIEhlbHBlciBGdW5jdGlvbnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHByb3ZpZGUgdXRpbGl0eSB0byBjaGVjayBlcnJvciBtZXNzYWdlIHF1YWxpdHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBjaGVja0Vycm9yTWVzc2FnZVF1YWxpdHkgPSAobWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNEZXRhaWxlZDogbWVzc2FnZS5sZW5ndGggPj0gMTUsXG4gICAgICAgICAgaGFzR3VpZGFuY2U6IC9wbGVhc2V8bXVzdHxzaG91bGR8cmVxdWlyZWQvaS50ZXN0KG1lc3NhZ2UpLFxuICAgICAgICAgIGlzTm90VmFndWU6ICEvXihpbnZhbGlkfGVycm9yfHdyb25nfGJhZCkkL2kudGVzdChtZXNzYWdlKSxcbiAgICAgICAgICBoYXNFeGFtcGxlOiBtZXNzYWdlLmluY2x1ZGVzKCdleGFtcGxlOicpXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvLyBUZXN0IGdvb2QgbWVzc2FnZXNcbiAgICAgIGNvbnN0IGdvb2RNZXNzYWdlcyA9IFtcbiAgICAgICAgJ1BsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MgKGV4YW1wbGU6IHVzZXJAZG9tYWluLmNvbSknLFxuICAgICAgICAnTmFtZSBpcyByZXF1aXJlZCAoZXhhbXBsZTogSmVhbiBEdXBvbnQpJyxcbiAgICAgICAgJ0Ftb3VudCBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyIHdpdGggdXAgdG8gMiBkZWNpbWFsIHBsYWNlcyAoZXhhbXBsZTogMTI1LjUwKSdcbiAgICAgIF07XG5cbiAgICAgIGdvb2RNZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICBjb25zdCBxdWFsaXR5ID0gY2hlY2tFcnJvck1lc3NhZ2VRdWFsaXR5KG1lc3NhZ2UpO1xuICAgICAgICBleHBlY3QocXVhbGl0eS5pc0RldGFpbGVkKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QocXVhbGl0eS5oYXNHdWlkYW5jZSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHF1YWxpdHkuaXNOb3RWYWd1ZSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUZXN0IGJhZCBtZXNzYWdlc1xuICAgICAgY29uc3QgYmFkTWVzc2FnZXMgPSBbJ0ludmFsaWQnLCAnUmVxdWlyZWQnLCAnRXJyb3InXTtcblxuICAgICAgYmFkTWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IGNoZWNrRXJyb3JNZXNzYWdlUXVhbGl0eShtZXNzYWdlKTtcbiAgICAgICAgZXhwZWN0KHF1YWxpdHkuaXNEZXRhaWxlZCkudG9CZShmYWxzZSk7XG4gICAgICAgIC8vIE5vdGU6ICdSZXF1aXJlZCcgZG9lc24ndCBtYXRjaCB0aGUgdmFndWUgcGF0dGVybiwgYnV0IGl0J3Mgc3RpbGwgbm90IGlkZWFsXG4gICAgICAgIGlmIChtZXNzYWdlID09PSAnSW52YWxpZCcgfHwgbWVzc2FnZSA9PT0gJ0Vycm9yJykge1xuICAgICAgICAgIGV4cGVjdChxdWFsaXR5LmlzTm90VmFndWUpLnRvQmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Z1dHVyZSBGb3JtIENvbXBsaWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHByb3ZpZGUgdGVtcGxhdGVzIGZvciBjb25zaXN0ZW50IGZvcm0gdmFsaWRhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb25UZW1wbGF0ZXMgPSB7XG4gICAgICAgIGVtYWlsOiAoKSA9PiB6LnN0cmluZygpLm1pbigxLCAnRW1haWwgYWRkcmVzcyBpcyByZXF1aXJlZCcpLmVtYWlsKCdQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzIChleGFtcGxlOiB1c2VyQGRvbWFpbi5jb20pJyksXG4gICAgICAgIG5hbWU6IChmaWVsZE5hbWU6IHN0cmluZywgZXhhbXBsZTogc3RyaW5nKSA9PiB6LnN0cmluZygpLm1pbigxLCBgJHtmaWVsZE5hbWV9IGlzIHJlcXVpcmVkIChleGFtcGxlOiAke2V4YW1wbGV9KWApLFxuICAgICAgICBwaG9uZTogKCkgPT4gei5zdHJpbmcoKS5yZWdleCgvXihcXCsxXFxzPyk/KFxcKFxcZHszfVxcKXxcXGR7M30pW1xccy4tXT9cXGR7M31bXFxzLi1dP1xcZHs0fSQvLCAnUGhvbmUgbnVtYmVyIG11c3QgYmUgYSB2YWxpZCBOb3J0aCBBbWVyaWNhbiBmb3JtYXQgKGV4YW1wbGU6ICg1MTQpIDEyMy00NTY3KScpLm9wdGlvbmFsKCksXG4gICAgICAgIGFtb3VudDogKCkgPT4gei5zdHJpbmcoKS5yZWdleCgvXlxcZCsoXFwuXFxkezEsMn0pPyQvLCAnQW1vdW50IG11c3QgYmUgYSB2YWxpZCBudW1iZXIgd2l0aCB1cCB0byAyIGRlY2ltYWwgcGxhY2VzIChleGFtcGxlOiAxMjUuNTApJyksXG4gICAgICAgIHNlbGVjdGlvbjogKGZpZWxkTmFtZTogc3RyaW5nKSA9PiB6LnN0cmluZygpLm1pbigxLCBgUGxlYXNlIHNlbGVjdCAke2ZpZWxkTmFtZX0gZnJvbSB0aGUgZHJvcGRvd25gKVxuICAgICAgfTtcblxuICAgICAgLy8gVGVzdCB0aGF0IHRlbXBsYXRlcyB3b3JrIGNvcnJlY3RseVxuICAgICAgZXhwZWN0KCgpID0+IHZhbGlkYXRpb25UZW1wbGF0ZXMuZW1haWwoKS5wYXJzZSgndXNlckBkb21haW4uY29tJykpLm5vdC50b1Rocm93KCk7XG4gICAgICBleHBlY3QoKCkgPT4gdmFsaWRhdGlvblRlbXBsYXRlcy5uYW1lKCdGaXJzdCBuYW1lJywgJ0plYW4nKS5wYXJzZSgnSmVhbicpKS5ub3QudG9UaHJvdygpO1xuICAgICAgZXhwZWN0KCgpID0+IHZhbGlkYXRpb25UZW1wbGF0ZXMuYW1vdW50KCkucGFyc2UoJzEyNS41MCcpKS5ub3QudG9UaHJvdygpO1xuXG4gICAgICAvLyBUZXN0IHRoYXQgdGVtcGxhdGVzIHByb2R1Y2UgaGVscGZ1bCBlcnJvciBtZXNzYWdlc1xuICAgICAgY29uc3QgZW1haWxFcnJvciA9IHZhbGlkYXRpb25UZW1wbGF0ZXMuZW1haWwoKS5zYWZlUGFyc2UoJ2ludmFsaWQnKTtcbiAgICAgIGNvbnN0IG5hbWVFcnJvciA9IHZhbGlkYXRpb25UZW1wbGF0ZXMubmFtZSgnRmlyc3QgbmFtZScsICdKZWFuJykuc2FmZVBhcnNlKCcnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGVtYWlsRXJyb3Iuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QobmFtZUVycm9yLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXBwbGljYXRpb24gQ29tcGxpYW5jZSBTdGFuZGFyZHMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGRlZmluZSBtaW5pbXVtIGNvbXBsaWFuY2UgcmVxdWlyZW1lbnRzIGZvciBhbGwgZm9ybXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wbGlhbmNlUmVxdWlyZW1lbnRzID0ge1xuICAgICAgICBlcnJvck1lc3NhZ2VzOiB7XG4gICAgICAgICAgbWluTGVuZ3RoOiAxNSxcbiAgICAgICAgICBtdXN0Q29udGFpbkd1aWRhbmNlOiB0cnVlLFxuICAgICAgICAgIHNob3VsZEluY2x1ZGVFeGFtcGxlczogdHJ1ZSxcbiAgICAgICAgICBhdm9pZFZhZ3VlTGFuZ3VhZ2U6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcXVlYmVjU3VwcG9ydDoge1xuICAgICAgICAgIGZyZW5jaENoYXJhY3RlcnM6IHRydWUsXG4gICAgICAgICAgY2FuYWRpYW5Gb3JtYXRzOiB0cnVlLFxuICAgICAgICAgIGFwcHJvcHJpYXRlRXhhbXBsZXM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgYWNjZXNzaWJpbGl0eToge1xuICAgICAgICAgIGRhdGFUZXN0SWRzOiB0cnVlLFxuICAgICAgICAgIHByb3BlckxhYmVsczogdHJ1ZSxcbiAgICAgICAgICBlcnJvckFzc29jaWF0aW9uOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHNlY3VyaXR5OiB7XG4gICAgICAgICAgcGFzc3dvcmRWYWxpZGF0aW9uOiB0cnVlLFxuICAgICAgICAgIHNlbnNpdGl2ZURhdGFQcm90ZWN0aW9uOiB0cnVlLFxuICAgICAgICAgIGNvbmZpcm1hdGlvbkZvckRlc3RydWN0aXZlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFZhbGlkYXRlIGFsbCByZXF1aXJlbWVudHMgYXJlIHByb3Blcmx5IGRlZmluZWRcbiAgICAgIE9iamVjdC5lbnRyaWVzKGNvbXBsaWFuY2VSZXF1aXJlbWVudHMpLmZvckVhY2goKFtjYXRlZ29yeSwgcmVxdWlyZW1lbnRzXSkgPT4ge1xuICAgICAgICBleHBlY3QoY2F0ZWdvcnkpLnRvTWF0Y2goL2Vycm9yTWVzc2FnZXN8cXVlYmVjU3VwcG9ydHxhY2Nlc3NpYmlsaXR5fHNlY3VyaXR5Lyk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJlcXVpcmVtZW50cykuZm9yRWFjaCgoW3JlcXVpcmVtZW50LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBleHBlY3QodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykudG9CZSh0cnVlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGV4cGVjdCh2YWx1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEZXZlbG9wbWVudCBXb3JrZmxvdyBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcHJvdmlkZSBjbGVhciBndWlkZWxpbmVzIGZvciBmb3JtIHZhbGlkYXRpb24gaW1wbGVtZW50YXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbXBsZW1lbnRhdGlvblN0ZXBzID0gW1xuICAgICAgICAnVXNlIFZhbGlkYXRpb25UZW1wbGF0ZXMgZnJvbSBmb3JtLXZhbGlkYXRpb24taGVscGVycy50cyBmb3IgY29uc2lzdGVudCBzY2hlbWFzJyxcbiAgICAgICAgJ0ltcGxlbWVudCBSZWFjdCBIb29rIEZvcm0gd2l0aCB6b2RSZXNvbHZlciBmb3IgdHlwZSBzYWZldHknLFxuICAgICAgICAnVXNlIEZvcm1MYWJlbCwgRm9ybUNvbnRyb2wsIEZvcm1NZXNzYWdlIGNvbXBvbmVudHMgZm9yIGNvbnNpc3RlbnQgVUknLFxuICAgICAgICAnQWRkIGRhdGEtdGVzdGlkIGF0dHJpYnV0ZXMgdG8gYWxsIGludGVyYWN0aXZlIGVsZW1lbnRzJyxcbiAgICAgICAgJ0luY2x1ZGUgdmFsaWRhdGlvbiB0ZXN0cyBmb3IgYWxsIG5ldyBmb3JtcycsXG4gICAgICAgICdWZXJpZnkgUXVlYmVjIGNvbXBsaWFuY2UgZm9yIG5hbWUgYW5kIGFkZHJlc3MgZmllbGRzJ1xuICAgICAgXTtcblxuICAgICAgLy8gVmFsaWRhdGUgaW1wbGVtZW50YXRpb24gc3RlcHMgYXJlIGNvbXByZWhlbnNpdmVcbiAgICAgIGV4cGVjdChpbXBsZW1lbnRhdGlvblN0ZXBzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCg2KTtcbiAgICAgIGltcGxlbWVudGF0aW9uU3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgICAgZXhwZWN0KHN0ZXAubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMjUpO1xuICAgICAgICBleHBlY3Qoc3RlcCkudG9NYXRjaCgvdXNlfGltcGxlbWVudHxhZGR8aW5jbHVkZXx2ZXJpZnkvaSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBlc3RhYmxpc2ggdGVzdGluZyByZXF1aXJlbWVudHMgZm9yIGZvcm0gdmFsaWRhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RpbmdSZXF1aXJlbWVudHMgPSBbXG4gICAgICAgICdUZXN0IHNjaGVtYSB2YWxpZGF0aW9uIHByb2R1Y2VzIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXMnLFxuICAgICAgICAnVGVzdCBVSSBkaXNwbGF5cyByZWQgbGFiZWxzIHdoZW4gdmFsaWRhdGlvbiBmYWlscycsXG4gICAgICAgICdUZXN0IGVycm9yIG1lc3NhZ2VzIGNsZWFyIHdoZW4gZmllbGRzIGJlY29tZSB2YWxpZCcsXG4gICAgICAgICdUZXN0IGFjY2Vzc2liaWxpdHkgY29tcGxpYW5jZSB3aXRoIHNjcmVlbiByZWFkZXJzJyxcbiAgICAgICAgJ1Rlc3QgUXVlYmVjIGNoYXJhY3RlciBzdXBwb3J0IGluIG5hbWUgZmllbGRzJyxcbiAgICAgICAgJ1Rlc3QgQ2FuYWRpYW4gZm9ybWF0IHZhbGlkYXRpb24gZm9yIHBvc3RhbCBjb2RlcyBhbmQgcGhvbmUgbnVtYmVycydcbiAgICAgIF07XG5cbiAgICAgIHRlc3RpbmdSZXF1aXJlbWVudHMuZm9yRWFjaChyZXF1aXJlbWVudCA9PiB7XG4gICAgICAgIGV4cGVjdChyZXF1aXJlbWVudCkudG9NYXRjaCgvdGVzdC9pKTtcbiAgICAgICAgZXhwZWN0KHJlcXVpcmVtZW50Lmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDMwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==