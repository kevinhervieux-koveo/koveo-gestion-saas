064f6d0cbd79277f5ba3614fea14c15a
'use strict';
var bracketDict = /*#__PURE__*/ function (bracketDict) {
    bracketDict["{"] = "}";
    bracketDict["["] = "]";
    return bracketDict;
}(bracketDict || {});
/**
 * Read the next key definition from user input
 *
 * Describe key per `{descriptor}` or `[descriptor]`.
 * Everything else will be interpreted as a single character as descriptor - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * A previously pressed key can be released per `{/descriptor}`.
 * Keeping the key pressed can be written as `{descriptor>}`.
 * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.
 * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.
 */ function readNextDescriptor(text, context) {
    let pos = 0;
    const startBracket = text[pos] in bracketDict ? text[pos] : '';
    pos += startBracket.length;
    const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
    const type = isEscapedChar ? '' : startBracket;
    return {
        type,
        ...type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context)
    };
}
function readPrintableChar(text, pos, context) {
    const descriptor = text[pos];
    assertDescriptor(descriptor, text, pos, context);
    pos += descriptor.length;
    return {
        consumedLength: pos,
        descriptor,
        releasePrevious: false,
        releaseSelf: true,
        repeat: 1
    };
}
function readTag(text, pos, startBracket, context) {
    var _text_slice_match, _text_slice_match1;
    const releasePreviousModifier = text[pos] === '/' ? '/' : '';
    pos += releasePreviousModifier.length;
    const escapedDescriptor = startBracket === '{' && text[pos] === '\\';
    pos += Number(escapedDescriptor);
    const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === undefined ? undefined : _text_slice_match[0];
    assertDescriptor(descriptor, text, pos, context);
    pos += descriptor.length;
    var _text_slice_match_;
    const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === undefined ? undefined : _text_slice_match1[0]) !== null && _text_slice_match_ !== undefined ? _text_slice_match_ : '';
    pos += repeatModifier.length;
    const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';
    pos += releaseSelfModifier.length;
    const expectedEndBracket = bracketDict[startBracket];
    const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
    if (!endBracket) {
        throw new Error(getErrorMessage([
            !repeatModifier && 'repeat modifier',
            !releaseSelfModifier && 'release modifier',
            `"${expectedEndBracket}"`
        ].filter(Boolean).join(' or '), text[pos], text, context));
    }
    pos += endBracket.length;
    return {
        consumedLength: pos,
        descriptor,
        releasePrevious: !!releasePreviousModifier,
        repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
        releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
    };
}
function assertDescriptor(descriptor, text, pos, context) {
    if (!descriptor) {
        throw new Error(getErrorMessage('key descriptor', text[pos], text, context));
    }
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
    if (releaseSelfModifier) {
        return releaseSelfModifier === '/';
    }
    if (repeatModifier) {
        return false;
    }
}
function getErrorMessage(expected, found, text, context) {
    return `Expected ${expected} but found "${found !== null && found !== undefined ? found : ''}" in "${text}"
    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
}
exports.readNextDescriptor = readNextDescriptor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50L2Rpc3QvY2pzL3V0aWxzL2tleURlZi9yZWFkTmV4dERlc2NyaXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDO0FBRWIsSUFBSSxXQUFXLEdBQUcsYUFBYSxDQUFDLFVBQVMsV0FBVztJQUNoRCxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ3ZCLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDdkIsT0FBTyxXQUFXLENBQUM7QUFDdkIsQ0FBQyxDQUFDLFdBQVcsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUNyQjs7Ozs7Ozs7OztHQVVHLENBQUMsU0FBUyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsT0FBTztJQUN6QyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDWixNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUMvRCxHQUFHLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQztJQUMzQixNQUFNLGFBQWEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxNQUFNLFlBQVksS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFDL0MsT0FBTztRQUNILElBQUk7UUFDSixHQUFHLElBQUksS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUM7S0FDN0YsQ0FBQztB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QUNqQixPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0FBQ0wsQ0FBQztBQUNELFNBQVMsZUFBZSxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU87SUFDbkQsT0FBTyxZQUFZLFFBQVEsZUFBZSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLElBQUk7VUFDbkcsT0FBTyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsOEZBQThGLENBQUMsQ0FBQyxDQUFDLHNEQUFzRDtnRUFDekgsQ0FBQztBQUNqRSxDQUFDO0FBRUQsT0FBTyxDQUFDLGtCQUFrQixHQUFHLGtCQUFrQixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudC9kaXN0L2Nqcy91dGlscy9rZXlEZWYvcmVhZE5leHREZXNjcmlwdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJyYWNrZXREaWN0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihicmFja2V0RGljdCkge1xuICAgIGJyYWNrZXREaWN0W1wie1wiXSA9IFwifVwiO1xuICAgIGJyYWNrZXREaWN0W1wiW1wiXSA9IFwiXVwiO1xuICAgIHJldHVybiBicmFja2V0RGljdDtcbn0oYnJhY2tldERpY3QgfHwge30pO1xuLyoqXG4gKiBSZWFkIHRoZSBuZXh0IGtleSBkZWZpbml0aW9uIGZyb20gdXNlciBpbnB1dFxuICpcbiAqIERlc2NyaWJlIGtleSBwZXIgYHtkZXNjcmlwdG9yfWAgb3IgYFtkZXNjcmlwdG9yXWAuXG4gKiBFdmVyeXRoaW5nIGVsc2Ugd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYXMgZGVzY3JpcHRvciAtIGUuZy4gYGFgLlxuICogQnJhY2tldHMgYHtgIGFuZCBgW2AgY2FuIGJlIGVzY2FwZWQgYnkgZG91YmxpbmcgLSBlLmcuIGBmb29bW2JhcmAgdHJhbnNsYXRlcyB0byBgZm9vW2JhcmAuXG4gKiBBIHByZXZpb3VzbHkgcHJlc3NlZCBrZXkgY2FuIGJlIHJlbGVhc2VkIHBlciBgey9kZXNjcmlwdG9yfWAuXG4gKiBLZWVwaW5nIHRoZSBrZXkgcHJlc3NlZCBjYW4gYmUgd3JpdHRlbiBhcyBge2Rlc2NyaXB0b3I+fWAuXG4gKiBXaGVuIGtlZXBpbmcgdGhlIGtleSBwcmVzc2VkIHlvdSBjYW4gY2hvb3NlIGhvdyBsb25nIHRoZSBrZXkgaXMgcHJlc3NlZCBge2Rlc2NyaXB0b3I+M31gLlxuICogWW91IGNhbiB0aGVuIHJlbGVhc2UgdGhlIGtleSBwZXIgYHtkZXNjcmlwdG9yPjMvfWAgb3Iga2VlcCBpdCBwcmVzc2VkIGFuZCBjb250aW51ZSB3aXRoIHRoZSBuZXh0IGtleS5cbiAqLyBmdW5jdGlvbiByZWFkTmV4dERlc2NyaXB0b3IodGV4dCwgY29udGV4dCkge1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHN0YXJ0QnJhY2tldCA9IHRleHRbcG9zXSBpbiBicmFja2V0RGljdCA/IHRleHRbcG9zXSA6ICcnO1xuICAgIHBvcyArPSBzdGFydEJyYWNrZXQubGVuZ3RoO1xuICAgIGNvbnN0IGlzRXNjYXBlZENoYXIgPSBuZXcgUmVnRXhwKGBeXFxcXCR7c3RhcnRCcmFja2V0fXsyfWApLnRlc3QodGV4dCk7XG4gICAgY29uc3QgdHlwZSA9IGlzRXNjYXBlZENoYXIgPyAnJyA6IHN0YXJ0QnJhY2tldDtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICAuLi50eXBlID09PSAnJyA/IHJlYWRQcmludGFibGVDaGFyKHRleHQsIHBvcywgY29udGV4dCkgOiByZWFkVGFnKHRleHQsIHBvcywgdHlwZSwgY29udGV4dClcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZFByaW50YWJsZUNoYXIodGV4dCwgcG9zLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRleHRbcG9zXTtcbiAgICBhc3NlcnREZXNjcmlwdG9yKGRlc2NyaXB0b3IsIHRleHQsIHBvcywgY29udGV4dCk7XG4gICAgcG9zICs9IGRlc2NyaXB0b3IubGVuZ3RoO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN1bWVkTGVuZ3RoOiBwb3MsXG4gICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgIHJlbGVhc2VQcmV2aW91czogZmFsc2UsXG4gICAgICAgIHJlbGVhc2VTZWxmOiB0cnVlLFxuICAgICAgICByZXBlYXQ6IDFcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZFRhZyh0ZXh0LCBwb3MsIHN0YXJ0QnJhY2tldCwgY29udGV4dCkge1xuICAgIHZhciBfdGV4dF9zbGljZV9tYXRjaCwgX3RleHRfc2xpY2VfbWF0Y2gxO1xuICAgIGNvbnN0IHJlbGVhc2VQcmV2aW91c01vZGlmaWVyID0gdGV4dFtwb3NdID09PSAnLycgPyAnLycgOiAnJztcbiAgICBwb3MgKz0gcmVsZWFzZVByZXZpb3VzTW9kaWZpZXIubGVuZ3RoO1xuICAgIGNvbnN0IGVzY2FwZWREZXNjcmlwdG9yID0gc3RhcnRCcmFja2V0ID09PSAneycgJiYgdGV4dFtwb3NdID09PSAnXFxcXCc7XG4gICAgcG9zICs9IE51bWJlcihlc2NhcGVkRGVzY3JpcHRvcik7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IGVzY2FwZWREZXNjcmlwdG9yID8gdGV4dFtwb3NdIDogKF90ZXh0X3NsaWNlX21hdGNoID0gdGV4dC5zbGljZShwb3MpLm1hdGNoKHN0YXJ0QnJhY2tldCA9PT0gJ3snID8gL15cXHcrfF5bXn0+L10vIDogL15cXHcrLykpID09PSBudWxsIHx8IF90ZXh0X3NsaWNlX21hdGNoID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfdGV4dF9zbGljZV9tYXRjaFswXTtcbiAgICBhc3NlcnREZXNjcmlwdG9yKGRlc2NyaXB0b3IsIHRleHQsIHBvcywgY29udGV4dCk7XG4gICAgcG9zICs9IGRlc2NyaXB0b3IubGVuZ3RoO1xuICAgIHZhciBfdGV4dF9zbGljZV9tYXRjaF87XG4gICAgY29uc3QgcmVwZWF0TW9kaWZpZXIgPSAoX3RleHRfc2xpY2VfbWF0Y2hfID0gKF90ZXh0X3NsaWNlX21hdGNoMSA9IHRleHQuc2xpY2UocG9zKS5tYXRjaCgvXj5cXGQrLykpID09PSBudWxsIHx8IF90ZXh0X3NsaWNlX21hdGNoMSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX3RleHRfc2xpY2VfbWF0Y2gxWzBdKSAhPT0gbnVsbCAmJiBfdGV4dF9zbGljZV9tYXRjaF8gIT09IHVuZGVmaW5lZCA/IF90ZXh0X3NsaWNlX21hdGNoXyA6ICcnO1xuICAgIHBvcyArPSByZXBlYXRNb2RpZmllci5sZW5ndGg7XG4gICAgY29uc3QgcmVsZWFzZVNlbGZNb2RpZmllciA9IHRleHRbcG9zXSA9PT0gJy8nIHx8ICFyZXBlYXRNb2RpZmllciAmJiB0ZXh0W3Bvc10gPT09ICc+JyA/IHRleHRbcG9zXSA6ICcnO1xuICAgIHBvcyArPSByZWxlYXNlU2VsZk1vZGlmaWVyLmxlbmd0aDtcbiAgICBjb25zdCBleHBlY3RlZEVuZEJyYWNrZXQgPSBicmFja2V0RGljdFtzdGFydEJyYWNrZXRdO1xuICAgIGNvbnN0IGVuZEJyYWNrZXQgPSB0ZXh0W3Bvc10gPT09IGV4cGVjdGVkRW5kQnJhY2tldCA/IGV4cGVjdGVkRW5kQnJhY2tldCA6ICcnO1xuICAgIGlmICghZW5kQnJhY2tldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNZXNzYWdlKFtcbiAgICAgICAgICAgICFyZXBlYXRNb2RpZmllciAmJiAncmVwZWF0IG1vZGlmaWVyJyxcbiAgICAgICAgICAgICFyZWxlYXNlU2VsZk1vZGlmaWVyICYmICdyZWxlYXNlIG1vZGlmaWVyJyxcbiAgICAgICAgICAgIGBcIiR7ZXhwZWN0ZWRFbmRCcmFja2V0fVwiYFxuICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgb3IgJyksIHRleHRbcG9zXSwgdGV4dCwgY29udGV4dCkpO1xuICAgIH1cbiAgICBwb3MgKz0gZW5kQnJhY2tldC5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3VtZWRMZW5ndGg6IHBvcyxcbiAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgcmVsZWFzZVByZXZpb3VzOiAhIXJlbGVhc2VQcmV2aW91c01vZGlmaWVyLFxuICAgICAgICByZXBlYXQ6IHJlcGVhdE1vZGlmaWVyID8gTWF0aC5tYXgoTnVtYmVyKHJlcGVhdE1vZGlmaWVyLnN1YnN0cigxKSksIDEpIDogMSxcbiAgICAgICAgcmVsZWFzZVNlbGY6IGhhc1JlbGVhc2VTZWxmKHJlbGVhc2VTZWxmTW9kaWZpZXIsIHJlcGVhdE1vZGlmaWVyKVxuICAgIH07XG59XG5mdW5jdGlvbiBhc3NlcnREZXNjcmlwdG9yKGRlc2NyaXB0b3IsIHRleHQsIHBvcywgY29udGV4dCkge1xuICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNZXNzYWdlKCdrZXkgZGVzY3JpcHRvcicsIHRleHRbcG9zXSwgdGV4dCwgY29udGV4dCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc1JlbGVhc2VTZWxmKHJlbGVhc2VTZWxmTW9kaWZpZXIsIHJlcGVhdE1vZGlmaWVyKSB7XG4gICAgaWYgKHJlbGVhc2VTZWxmTW9kaWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlbGVhc2VTZWxmTW9kaWZpZXIgPT09ICcvJztcbiAgICB9XG4gICAgaWYgKHJlcGVhdE1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kLCB0ZXh0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGBFeHBlY3RlZCAke2V4cGVjdGVkfSBidXQgZm91bmQgXCIke2ZvdW5kICE9PSBudWxsICYmIGZvdW5kICE9PSB1bmRlZmluZWQgPyBmb3VuZCA6ICcnfVwiIGluIFwiJHt0ZXh0fVwiXG4gICAgU2VlICR7Y29udGV4dCA9PT0gJ3BvaW50ZXInID8gYGh0dHBzOi8vdGVzdGluZy1saWJyYXJ5LmNvbS9kb2NzL3VzZXItZXZlbnQvcG9pbnRlciNwcmVzc2luZy1hLWJ1dHRvbi1vci10b3VjaGluZy10aGUtc2NyZWVuYCA6IGBodHRwczovL3Rlc3RpbmctbGlicmFyeS5jb20vZG9jcy91c2VyLWV2ZW50L2tleWJvYXJkYH1cbiAgICBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgdXNlckV2ZW50IHBhcnNlcyB5b3VyIGlucHV0LmA7XG59XG5cbmV4cG9ydHMucmVhZE5leHREZXNjcmlwdG9yID0gcmVhZE5leHREZXNjcmlwdG9yO1xuIl0sInZlcnNpb24iOjN9