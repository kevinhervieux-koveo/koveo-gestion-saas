{"file":"/home/runner/workspace/server/services/gemini-bill-analyzer.ts","mappings":"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","names":[],"sources":["/home/runner/workspace/server/services/gemini-bill-analyzer.ts"],"sourcesContent":["import * as fs from 'fs';\nimport { GoogleGenAI } from '@google/genai';\n\n// DON'T DELETE THIS COMMENT\n// Follow these instructions when using this blueprint:\n// - Note that the newest Gemini model series is \"gemini-2.5-flash\" or gemini-2.5-pro\"\n//   - do not change this unless explicitly requested by the user\n\n// This API key is from Gemini Developer API Key, not vertex AI API Key\nconst ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || '' });\n\n/**\n *\n */\nexport interface BillAnalysisResult {\n  title: string;\n  vendor: string;\n  totalAmount: string;\n  category: string;\n  description?: string;\n  dueDate?: string;\n  issueDate?: string;\n  billNumber?: string;\n  confidence: number;\n}\n\n/**\n *\n */\nexport class GeminiBillAnalyzer {\n  /**\n   * Analyze a bill document using Gemini 2.5 Pro.\n   * @param filePath\n   * @param mimeType \n   */\n  async analyzeBillDocument(filePath: string, mimeType?: string): Promise<BillAnalysisResult> {\n    try {\n      const fileBytes = fs.readFileSync(filePath);\n      \n      // Detect MIME type if not provided  \n      const detectedMimeType = mimeType || this.detectMimeType(filePath);\n\n      const systemPrompt = `You are an expert bill analysis AI. Analyze this bill/invoice document and extract key information.\n      \n      Extract the following information and respond with JSON in this exact format:\n      {\n        \"title\": \"Brief descriptive title for this bill\",\n        \"vendor\": \"Company or service provider name\",\n        \"totalAmount\": \"Total amount as decimal string (e.g., '1234.56')\",\n        \"category\": \"One of: insurance, maintenance, salary, utilities, cleaning, security, landscaping, professional_services, administration, repairs, supplies, taxes, technology, reserves, other\",\n        \"description\": \"Brief description of services/products\",\n        \"dueDate\": \"Due date in YYYY-MM-DD format if found\",\n        \"issueDate\": \"Issue date in YYYY-MM-DD format if found\", \n        \"billNumber\": \"Bill/invoice number if found\",\n        \"confidence\": 0.85\n      }\n      \n      Guidelines:\n      - Use clear, concise titles (e.g., \"Hydro-Qu√©bec Electricity Bill\", \"Property Insurance Premium\")\n      - Map categories intelligently (electricity = utilities, legal fees = professional_services, etc.)\n      - Extract exact amounts without currency symbols\n      - Confidence should reflect how clear the document is (0.0-1.0)\n      - If information is unclear, use best guess but lower confidence\n      \n      **IMPORTANT: Your response MUST be a raw JSON object only, without any Markdown formatting, backticks, or explanatory text. Do not wrap the JSON in triple backticks or any other non-JSON characters.**`;\n\n      const response = await ai.models.generateContent({\n        model: 'gemini-1.5-flash',\n        contents: [\n          {\n            role: 'user',\n            parts: [\n              { text: systemPrompt },\n              {\n                inlineData: {\n                  mimeType: detectedMimeType,\n                  data: fileBytes.toString('base64')\n                }\n              }\n            ]\n          }\n        ]\n      });\n\n      const rawJson = response.text;\n\n      if (rawJson) {\n        // Sanitize the response by removing markdown code blocks\n        const sanitizedJson = this.sanitizeJsonResponse(rawJson);\n        \n        let analysis: BillAnalysisResult;\n        \n        try {\n          analysis = JSON.parse(sanitizedJson);\n        } catch (parseError) {\n          console.error('JSON parsing failed for AI response:', parseError);\n          throw new Error('Failed to parse AI response as JSON');\n        }\n\n        // Validate and sanitize the results\n        analysis = this.sanitizeAndValidateAnalysis(analysis);\n\n        return analysis;\n      } else {\n        throw new Error('Empty response from Gemini');\n      }\n    } catch (error: any) {\n      console.error('Error analyzing bill document:', error);\n      throw new Error(`Failed to analyze bill document: ${error}`);\n    }\n  }\n\n  /**\n   * Sanitize JSON response by removing markdown code blocks and whitespace.\n   * @param rawResponse The raw response from the AI\n   * @returns Clean JSON string\n   */\n  private sanitizeJsonResponse(rawResponse: string): string {\n    if (!rawResponse) {\n      return rawResponse;\n    }\n\n    // Remove markdown code blocks (```json and ```)\n    let cleaned = rawResponse\n      .replace(/```json\\s*/gi, '') // Remove opening ```json with optional whitespace\n      .replace(/```\\s*$/g, '') // Remove closing ``` at end with optional whitespace\n      .replace(/^```\\s*/g, '') // Remove opening ``` at start with optional whitespace\n      .trim(); // Remove leading/trailing whitespace\n\n    return cleaned;\n  }\n\n  /**\n   * Detect MIME type from file path.\n   * @param filePath\n   */\n  private detectMimeType(filePath: string): string {\n    const extension = filePath.toLowerCase().split('.').pop();\n    \n    switch (extension) {\n      case 'pdf':\n        return 'application/pdf';\n      case 'jpg':\n      case 'jpeg':\n        return 'image/jpeg';\n      case 'png':\n        return 'image/png';\n      case 'gif':\n        return 'image/gif';\n      case 'webp':\n        return 'image/webp';\n      default:\n        // Default to PDF since that's what we're trying to support\n        return 'application/pdf';\n    }\n  }\n\n  /**\n   * Comprehensive sanitization and validation of AI analysis results\n   * Prevents XSS, SQL injection, and data integrity issues\n   * @param analysis Raw analysis from AI\n   * @returns Sanitized and validated analysis\n   */\n  private sanitizeAndValidateAnalysis(analysis: BillAnalysisResult): BillAnalysisResult {\n    return {\n      title: this.sanitizeString(analysis.title || ''),\n      vendor: this.sanitizeString(analysis.vendor || ''),\n      totalAmount: this.sanitizeAmount(analysis.totalAmount || '0'),\n      category: this.validateCategory(analysis.category || 'other'),\n      description: this.sanitizeString(analysis.description || ''),\n      dueDate: this.validateDate(analysis.dueDate),\n      issueDate: this.validateDate(analysis.issueDate),\n      billNumber: this.sanitizeString(analysis.billNumber || ''),\n      confidence: this.validateConfidence(analysis.confidence || 0)\n    };\n  }\n\n  /**\n   * Sanitize string fields to prevent XSS and SQL injection\n   * @param input Raw string input\n   * @returns Sanitized string\n   */\n  private sanitizeString(input: string): string {\n    if (!input || typeof input !== 'string') {\n      return '';\n    }\n\n    return input\n      // Remove HTML tags and potential XSS\n      .replace(/<[^>]*>/g, '')\n      // Remove script tags specifically\n      .replace(/javascript:/gi, '')\n      // Remove SQL injection patterns\n      .replace(/(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\\b)/gi, '')\n      // Remove potential command injection\n      .replace(/[;&|`$(){}[\\]]/g, '')\n      // Limit length to prevent DoS\n      .substring(0, 1000)\n      .trim();\n  }\n\n  /**\n   * Sanitize and validate amount string.\n   * @param amount Raw amount string\n   * @returns Validated amount in decimal format\n   */\n  private sanitizeAmount(amount: string): string {\n    if (!amount || typeof amount !== 'string') {\n      return '0.00';\n    }\n\n    // Remove dangerous characters and keep only numbers, dots, commas\n    const cleaned = amount.replace(/[^0-9.,-]/g, '');\n    \n    // Handle comma as decimal separator (European format)\n    const normalizedAmount = cleaned.replace(/,/g, '.');\n    \n    // Remove extra dots (keep only the last one as decimal separator)\n    const parts = normalizedAmount.split('.');\n    const sanitized = parts.length > 1 \n      ? parts.slice(0, -1).join('') + '.' + parts[parts.length - 1]\n      : parts[0];\n\n    const parsed = parseFloat(sanitized);\n\n    // Validate range and format\n    if (isNaN(parsed) || parsed < 0 || parsed > 999999.99) {\n      return '0.00';\n    }\n\n    return parsed.toFixed(2);\n  }\n\n  /**\n   * Validate and sanitize category\n   * @param category Raw category from AI\n   * @returns Valid category or 'other'\n   */\n  private validateCategory(category: string): string {\n    const validCategories = [\n      'insurance', 'maintenance', 'salary', 'utilities', 'cleaning',\n      'security', 'landscaping', 'professional_services', 'administration',\n      'repairs', 'supplies', 'taxes', 'technology', 'reserves', 'other'\n    ];\n\n    const sanitized = this.sanitizeString(category).toLowerCase();\n    return validCategories.includes(sanitized) ? sanitized : 'other';\n  }\n\n  /**\n   * Validate date format\n   * @param dateString Raw date string\n   * @returns Valid ISO date string or undefined\n   */\n  private validateDate(dateString?: string): string | undefined {\n    if (!dateString || typeof dateString !== 'string') {\n      return undefined;\n    }\n\n    const sanitized = this.sanitizeString(dateString);\n    const date = new Date(sanitized);\n    \n    // Check if date is valid and within reasonable range (not too far in past/future)\n    const now = new Date();\n    const tenYearsAgo = new Date(now.getFullYear() - 10, 0, 1);\n    const fiveYearsFromNow = new Date(now.getFullYear() + 5, 11, 31);\n\n    if (isNaN(date.getTime()) || date < tenYearsAgo || date > fiveYearsFromNow) {\n      return undefined;\n    }\n\n    return date.toISOString().split('T')[0];\n  }\n\n  /**\n   * Validate confidence value\n   * @param confidence Raw confidence value\n   * @returns Clamped confidence between 0.0 and 1.0\n   */\n  private validateConfidence(confidence: number): number {\n    if (typeof confidence !== 'number' || isNaN(confidence)) {\n      return 0.0;\n    }\n    return Math.max(0, Math.min(1, confidence));\n  }\n\n  /**\n   * Get suggested payment schedule based on bill type and amount.\n   * @param category\n   * @param amount\n   */\n  async suggestPaymentSchedule(\n    category: string,\n    amount: number\n  ): Promise<{\n    paymentType: 'unique' | 'recurrent';\n    schedulePayment?: 'monthly' | 'quarterly' | 'yearly';\n    reasoning: string;\n  }> {\n    try {\n      const prompt = `Based on this bill category \"${category}\" and amount $${amount}, suggest the most appropriate payment schedule.\n      \n      Common patterns:\n      - Utilities: Usually monthly recurring\n      - Insurance: Usually yearly recurring  \n      - Maintenance: Usually unique payments\n      - Professional services: Usually unique payments\n      - Supplies: Usually unique payments\n      - Taxes: Usually yearly recurring\n      \n      Respond with JSON:\n      {\n        \"paymentType\": \"unique\" or \"recurrent\",\n        \"schedulePayment\": \"monthly\", \"quarterly\", or \"yearly\" (only if recurrent),\n        \"reasoning\": \"Brief explanation of the recommendation\"\n      }`;\n\n      const response = await ai.models.generateContent({\n        model: 'gemini-2.5-flash',\n        config: {\n          responseMimeType: 'application/json',\n          responseSchema: {\n            type: 'object',\n            properties: {\n              paymentType: { type: 'string', enum: ['unique', 'recurrent'] },\n              schedulePayment: { type: 'string', enum: ['monthly', 'quarterly', 'yearly'] },\n              reasoning: { type: 'string' },\n            },\n            required: ['paymentType', 'reasoning'],\n          },\n        },\n        contents: prompt,\n      });\n\n      const result = JSON.parse(response.text || '{}');\n      return result;\n    } catch (error: any) {\n      console.error('‚ùå Error suggesting payment schedule:', error);\n      return {\n        paymentType: 'unique',\n        reasoning: 'Default to unique payment due to analysis error',\n      };\n    }\n  }\n}\n\nexport const geminiBillAnalyzer = new GeminiBillAnalyzer();\n"],"version":3}