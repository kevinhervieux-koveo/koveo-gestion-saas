1917fa0172bddf33fa91c6819b29c8a8
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.waitFor = waitForWrapper;
var _helpers = require("./helpers");
var _config = require("./config");
// This is so the stack trace the developer sees is one that's
// closer to their code (because async stack traces are hard to follow).
function copyStackTrace(target, source) {
    target.stack = source.stack.replace(source.message, target.message);
}
function waitFor(callback, { container = (0, _helpers.getDocument)(), timeout = (0, _config.getConfig)().asyncUtilTimeout, showOriginalStackTrace = (0, _config.getConfig)().showOriginalStackTrace, stackTraceError, interval = 50, onTimeout = error => {
    Object.defineProperty(error, 'message', {
        value: (0, _config.getConfig)().getElementError(error.message, container).message
    });
    return error;
}, mutationObserverOptions = {
    subtree: true,
    childList: true,
    attributes: true,
    characterData: true
} }) {
    if (typeof callback !== 'function') {
        throw new TypeError('Received `callback` arg must be a function');
    }
    return new Promise(async (resolve, reject) => {
        let lastError, intervalId, observer;
        let finished = false;
        let promiseStatus = 'idle';
        const overallTimeoutTimer = setTimeout(handleTimeout, timeout);
        const usingJestFakeTimers = (0, _helpers.jestFakeTimersAreEnabled)();
        if (usingJestFakeTimers) {
            const { unstable_advanceTimersWrapper: advanceTimersWrapper } = (0, _config.getConfig)();
            checkCallback();
            // this is a dangerous rule to disable because it could lead to an
            // infinite loop. However, eslint isn't smart enough to know that we're
            // setting finished inside `onDone` which will be called when we're done
            // waiting or when we've timed out.
            // eslint-disable-next-line no-unmodified-loop-condition
            while (!finished) {
                if (!(0, _helpers.jestFakeTimersAreEnabled)()) {
                    const error = new Error(`Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830`);
                    if (!showOriginalStackTrace)
                        copyStackTrace(error, stackTraceError);
                    reject(error);
                    return;
                }
                // In this rare case, we *need* to wait for in-flight promises
                // to resolve before continuing. We don't need to take advantage
                // of parallelization so we're fine.
                // https://stackoverflow.com/a/59243586/971592
                // eslint-disable-next-line no-await-in-loop
                await advanceTimersWrapper(async () => {
                    // we *could* (maybe should?) use `advanceTimersToNextTimer` but it's
                    // possible that could make this loop go on forever if someone is using
                    // third party code that's setting up recursive timers so rapidly that
                    // the user's timer's don't get a chance to resolve. So we'll advance
                    // by an interval instead. (We have a test for this case).
                    jest.advanceTimersByTime(interval);
                });
                // Could have timed-out
                if (finished) {
                    break;
                }
                // It's really important that checkCallback is run *before* we flush
                // in-flight promises. To be honest, I'm not sure why, and I can't quite
                // think of a way to reproduce the problem in a test, but I spent
                // an entire day banging my head against a wall on this.
                checkCallback();
            }
        }
        else {
            try {
                (0, _helpers.checkContainerType)(container);
            }
            catch (e) {
                reject(e);
                return;
            }
            intervalId = setInterval(checkRealTimersCallback, interval);
            const { MutationObserver } = (0, _helpers.getWindowFromNode)(container);
            observer = new MutationObserver(checkRealTimersCallback);
            observer.observe(container, mutationObserverOptions);
            checkCallback();
        }
        function onDone(error, result) {
            finished = true;
            clearTimeout(overallTimeoutTimer);
            if (!usingJestFakeTimers) {
                clearInterval(intervalId);
                observer.disconnect();
            }
            if (error) {
                reject(error);
            }
            else {
                resolve(result);
            }
        }
        function checkRealTimersCallback() {
            if ((0, _helpers.jestFakeTimersAreEnabled)()) {
                const error = new Error(`Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830`);
                if (!showOriginalStackTrace)
                    copyStackTrace(error, stackTraceError);
                return reject(error);
            }
            else {
                return checkCallback();
            }
        }
        function checkCallback() {
            if (promiseStatus === 'pending')
                return;
            try {
                const result = (0, _config.runWithExpensiveErrorDiagnosticsDisabled)(callback);
                if (typeof result?.then === 'function') {
                    promiseStatus = 'pending';
                    result.then(resolvedValue => {
                        promiseStatus = 'resolved';
                        onDone(null, resolvedValue);
                    }, rejectedValue => {
                        promiseStatus = 'rejected';
                        lastError = rejectedValue;
                    });
                }
                else {
                    onDone(null, result);
                }
                // If `callback` throws, wait for the next mutation, interval, or timeout.
            }
            catch (error) {
                // Save the most recent callback error to reject the promise with it in the event of a timeout
                lastError = error;
            }
        }
        function handleTimeout() {
            let error;
            if (lastError) {
                error = lastError;
                if (!showOriginalStackTrace && error.name === 'TestingLibraryElementError') {
                    copyStackTrace(error, stackTraceError);
                }
            }
            else {
                error = new Error('Timed out in waitFor.');
                if (!showOriginalStackTrace) {
                    copyStackTrace(error, stackTraceError);
                }
            }
            onDone(onTimeout(error), null);
        }
    });
}
function waitForWrapper(callback, options) {
    // create the error here so its stack trace is as close to the
    // calling code as possible
    const stackTraceError = new Error('STACK_TRACE_MESSAGE');
    return (0, _config.getConfig)().asyncWrapper(() => waitFor(callback, {
        stackTraceError,
        ...options
    }));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC93YWl0LWZvci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLENBQUM7QUFFYixNQUFNLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUU7SUFDM0MsS0FBSyxFQUFFLElBQUk7Q0FDWixDQUFDLENBQUM7QUFDSCxPQUFPLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQztBQUNqQyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDcEMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2xDLDhEQUE4RDtBQUM5RCx3RUFBd0U7QUFDeEUsU0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFLE1BQU07SUFDcEMsTUFBTSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN0RSxDQUFDO0FBQ0QsU0FBUyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQ3pCLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFDdkMsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLGdCQUFnQixFQUNuRCxzQkFBc0IsR0FBRyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxzQkFBc0IsRUFDeEUsZUFBZSxFQUNmLFFBQVEsR0FBRyxFQUFFLEVBQ2IsU0FBUyxHQUFHLEtBQUssQ0FBQyxFQUFFO0lBQ2xCLE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRTtRQUN0QyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEtBQUss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QyxDQUFDO1FBQ2pDLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFDRCxTQUFTLGNBQWMsQ0FBQyxRQUFRLEVBQUUsT0FBTztJQUN2Qyw4REFBOEQ7SUFDOUQsMkJBQTJCO0lBQzNCLE1BQU0sZUFBZSxHQUFHLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDekQsT0FBTyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRTtRQUNuRSxlQUFlO1FBQ2YsR0FBRyxPQUFPO0tBQ1gsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0B0ZXN0aW5nLWxpYnJhcnkvZG9tL2Rpc3Qvd2FpdC1mb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLndhaXRGb3IgPSB3YWl0Rm9yV3JhcHBlcjtcbnZhciBfaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbi8vIFRoaXMgaXMgc28gdGhlIHN0YWNrIHRyYWNlIHRoZSBkZXZlbG9wZXIgc2VlcyBpcyBvbmUgdGhhdCdzXG4vLyBjbG9zZXIgdG8gdGhlaXIgY29kZSAoYmVjYXVzZSBhc3luYyBzdGFjayB0cmFjZXMgYXJlIGhhcmQgdG8gZm9sbG93KS5cbmZ1bmN0aW9uIGNvcHlTdGFja1RyYWNlKHRhcmdldCwgc291cmNlKSB7XG4gIHRhcmdldC5zdGFjayA9IHNvdXJjZS5zdGFjay5yZXBsYWNlKHNvdXJjZS5tZXNzYWdlLCB0YXJnZXQubWVzc2FnZSk7XG59XG5mdW5jdGlvbiB3YWl0Rm9yKGNhbGxiYWNrLCB7XG4gIGNvbnRhaW5lciA9ICgwLCBfaGVscGVycy5nZXREb2N1bWVudCkoKSxcbiAgdGltZW91dCA9ICgwLCBfY29uZmlnLmdldENvbmZpZykoKS5hc3luY1V0aWxUaW1lb3V0LFxuICBzaG93T3JpZ2luYWxTdGFja1RyYWNlID0gKDAsIF9jb25maWcuZ2V0Q29uZmlnKSgpLnNob3dPcmlnaW5hbFN0YWNrVHJhY2UsXG4gIHN0YWNrVHJhY2VFcnJvcixcbiAgaW50ZXJ2YWwgPSA1MCxcbiAgb25UaW1lb3V0ID0gZXJyb3IgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ21lc3NhZ2UnLCB7XG4gICAgICB2YWx1ZTogKDAsIF9jb25maWcuZ2V0Q29uZmlnKSgpLmdldEVsZW1lbnRFcnJvcihlcnJvci5tZXNzYWdlLCBjb250YWluZXIpLm1lc3NhZ2VcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0sXG4gIG11dGF0aW9uT2JzZXJ2ZXJPcHRpb25zID0ge1xuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9XG59KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWNlaXZlZCBgY2FsbGJhY2tgIGFyZyBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBsYXN0RXJyb3IsIGludGVydmFsSWQsIG9ic2VydmVyO1xuICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIGxldCBwcm9taXNlU3RhdHVzID0gJ2lkbGUnO1xuICAgIGNvbnN0IG92ZXJhbGxUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHRpbWVvdXQpO1xuICAgIGNvbnN0IHVzaW5nSmVzdEZha2VUaW1lcnMgPSAoMCwgX2hlbHBlcnMuamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKSgpO1xuICAgIGlmICh1c2luZ0plc3RGYWtlVGltZXJzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHVuc3RhYmxlX2FkdmFuY2VUaW1lcnNXcmFwcGVyOiBhZHZhbmNlVGltZXJzV3JhcHBlclxuICAgICAgfSA9ICgwLCBfY29uZmlnLmdldENvbmZpZykoKTtcbiAgICAgIGNoZWNrQ2FsbGJhY2soKTtcbiAgICAgIC8vIHRoaXMgaXMgYSBkYW5nZXJvdXMgcnVsZSB0byBkaXNhYmxlIGJlY2F1c2UgaXQgY291bGQgbGVhZCB0byBhblxuICAgICAgLy8gaW5maW5pdGUgbG9vcC4gSG93ZXZlciwgZXNsaW50IGlzbid0IHNtYXJ0IGVub3VnaCB0byBrbm93IHRoYXQgd2UncmVcbiAgICAgIC8vIHNldHRpbmcgZmluaXNoZWQgaW5zaWRlIGBvbkRvbmVgIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW4gd2UncmUgZG9uZVxuICAgICAgLy8gd2FpdGluZyBvciB3aGVuIHdlJ3ZlIHRpbWVkIG91dC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bm1vZGlmaWVkLWxvb3AtY29uZGl0aW9uXG4gICAgICB3aGlsZSAoIWZpbmlzaGVkKSB7XG4gICAgICAgIGlmICghKDAsIF9oZWxwZXJzLmplc3RGYWtlVGltZXJzQXJlRW5hYmxlZCkoKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBDaGFuZ2VkIGZyb20gdXNpbmcgZmFrZSB0aW1lcnMgdG8gcmVhbCB0aW1lcnMgd2hpbGUgdXNpbmcgd2FpdEZvci4gVGhpcyBpcyBub3QgYWxsb3dlZCBhbmQgd2lsbCByZXN1bHQgaW4gdmVyeSBzdHJhbmdlIGJlaGF2aW9yLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBhd2FpdGluZyBhbGwgYXN5bmMgdGhpbmdzIHlvdXIgdGVzdCBpcyBkb2luZyBiZWZvcmUgY2hhbmdpbmcgdG8gcmVhbCB0aW1lcnMuIEZvciBtb3JlIGluZm8sIHBsZWFzZSBnbyB0byBodHRwczovL2dpdGh1Yi5jb20vdGVzdGluZy1saWJyYXJ5L2RvbS10ZXN0aW5nLWxpYnJhcnkvaXNzdWVzLzgzMGApO1xuICAgICAgICAgIGlmICghc2hvd09yaWdpbmFsU3RhY2tUcmFjZSkgY29weVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrVHJhY2VFcnJvcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiB0aGlzIHJhcmUgY2FzZSwgd2UgKm5lZWQqIHRvIHdhaXQgZm9yIGluLWZsaWdodCBwcm9taXNlc1xuICAgICAgICAvLyB0byByZXNvbHZlIGJlZm9yZSBjb250aW51aW5nLiBXZSBkb24ndCBuZWVkIHRvIHRha2UgYWR2YW50YWdlXG4gICAgICAgIC8vIG9mIHBhcmFsbGVsaXphdGlvbiBzbyB3ZSdyZSBmaW5lLlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTkyNDM1ODYvOTcxNTkyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgIGF3YWl0IGFkdmFuY2VUaW1lcnNXcmFwcGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyB3ZSAqY291bGQqIChtYXliZSBzaG91bGQ/KSB1c2UgYGFkdmFuY2VUaW1lcnNUb05leHRUaW1lcmAgYnV0IGl0J3NcbiAgICAgICAgICAvLyBwb3NzaWJsZSB0aGF0IGNvdWxkIG1ha2UgdGhpcyBsb29wIGdvIG9uIGZvcmV2ZXIgaWYgc29tZW9uZSBpcyB1c2luZ1xuICAgICAgICAgIC8vIHRoaXJkIHBhcnR5IGNvZGUgdGhhdCdzIHNldHRpbmcgdXAgcmVjdXJzaXZlIHRpbWVycyBzbyByYXBpZGx5IHRoYXRcbiAgICAgICAgICAvLyB0aGUgdXNlcidzIHRpbWVyJ3MgZG9uJ3QgZ2V0IGEgY2hhbmNlIHRvIHJlc29sdmUuIFNvIHdlJ2xsIGFkdmFuY2VcbiAgICAgICAgICAvLyBieSBhbiBpbnRlcnZhbCBpbnN0ZWFkLiAoV2UgaGF2ZSBhIHRlc3QgZm9yIHRoaXMgY2FzZSkuXG4gICAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKGludGVydmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ291bGQgaGF2ZSB0aW1lZC1vdXRcbiAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyByZWFsbHkgaW1wb3J0YW50IHRoYXQgY2hlY2tDYWxsYmFjayBpcyBydW4gKmJlZm9yZSogd2UgZmx1c2hcbiAgICAgICAgLy8gaW4tZmxpZ2h0IHByb21pc2VzLiBUbyBiZSBob25lc3QsIEknbSBub3Qgc3VyZSB3aHksIGFuZCBJIGNhbid0IHF1aXRlXG4gICAgICAgIC8vIHRoaW5rIG9mIGEgd2F5IHRvIHJlcHJvZHVjZSB0aGUgcHJvYmxlbSBpbiBhIHRlc3QsIGJ1dCBJIHNwZW50XG4gICAgICAgIC8vIGFuIGVudGlyZSBkYXkgYmFuZ2luZyBteSBoZWFkIGFnYWluc3QgYSB3YWxsIG9uIHRoaXMuXG4gICAgICAgIGNoZWNrQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgKDAsIF9oZWxwZXJzLmNoZWNrQ29udGFpbmVyVHlwZSkoY29udGFpbmVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoY2hlY2tSZWFsVGltZXJzQ2FsbGJhY2ssIGludGVydmFsKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgTXV0YXRpb25PYnNlcnZlclxuICAgICAgfSA9ICgwLCBfaGVscGVycy5nZXRXaW5kb3dGcm9tTm9kZSkoY29udGFpbmVyKTtcbiAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hlY2tSZWFsVGltZXJzQ2FsbGJhY2spO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIG11dGF0aW9uT2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIGNoZWNrQ2FsbGJhY2soKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Eb25lKGVycm9yLCByZXN1bHQpIHtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dChvdmVyYWxsVGltZW91dFRpbWVyKTtcbiAgICAgIGlmICghdXNpbmdKZXN0RmFrZVRpbWVycykge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tSZWFsVGltZXJzQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoKDAsIF9oZWxwZXJzLmplc3RGYWtlVGltZXJzQXJlRW5hYmxlZCkoKSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQ2hhbmdlZCBmcm9tIHVzaW5nIHJlYWwgdGltZXJzIHRvIGZha2UgdGltZXJzIHdoaWxlIHVzaW5nIHdhaXRGb3IuIFRoaXMgaXMgbm90IGFsbG93ZWQgYW5kIHdpbGwgcmVzdWx0IGluIHZlcnkgc3RyYW5nZSBiZWhhdmlvci4gUGxlYXNlIGVuc3VyZSB5b3UncmUgYXdhaXRpbmcgYWxsIGFzeW5jIHRoaW5ncyB5b3VyIHRlc3QgaXMgZG9pbmcgYmVmb3JlIGNoYW5naW5nIHRvIGZha2UgdGltZXJzLiBGb3IgbW9yZSBpbmZvLCBwbGVhc2UgZ28gdG8gaHR0cHM6Ly9naXRodWIuY29tL3Rlc3RpbmctbGlicmFyeS9kb20tdGVzdGluZy1saWJyYXJ5L2lzc3Vlcy84MzBgKTtcbiAgICAgICAgaWYgKCFzaG93T3JpZ2luYWxTdGFja1RyYWNlKSBjb3B5U3RhY2tUcmFjZShlcnJvciwgc3RhY2tUcmFjZUVycm9yKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hlY2tDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NhbGxiYWNrKCkge1xuICAgICAgaWYgKHByb21pc2VTdGF0dXMgPT09ICdwZW5kaW5nJykgcmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9jb25maWcucnVuV2l0aEV4cGVuc2l2ZUVycm9yRGlhZ25vc3RpY3NEaXNhYmxlZCkoY2FsbGJhY2spO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdD8udGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb21pc2VTdGF0dXMgPSAncGVuZGluZyc7XG4gICAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZWRWYWx1ZSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlU3RhdHVzID0gJ3Jlc29sdmVkJztcbiAgICAgICAgICAgIG9uRG9uZShudWxsLCByZXNvbHZlZFZhbHVlKTtcbiAgICAgICAgICB9LCByZWplY3RlZFZhbHVlID0+IHtcbiAgICAgICAgICAgIHByb21pc2VTdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgbGFzdEVycm9yID0gcmVqZWN0ZWRWYWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkRvbmUobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBgY2FsbGJhY2tgIHRocm93cywgd2FpdCBmb3IgdGhlIG5leHQgbXV0YXRpb24sIGludGVydmFsLCBvciB0aW1lb3V0LlxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gU2F2ZSB0aGUgbW9zdCByZWNlbnQgY2FsbGJhY2sgZXJyb3IgdG8gcmVqZWN0IHRoZSBwcm9taXNlIHdpdGggaXQgaW4gdGhlIGV2ZW50IG9mIGEgdGltZW91dFxuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBsYXN0RXJyb3I7XG4gICAgICAgIGlmICghc2hvd09yaWdpbmFsU3RhY2tUcmFjZSAmJiBlcnJvci5uYW1lID09PSAnVGVzdGluZ0xpYnJhcnlFbGVtZW50RXJyb3InKSB7XG4gICAgICAgICAgY29weVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrVHJhY2VFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdUaW1lZCBvdXQgaW4gd2FpdEZvci4nKTtcbiAgICAgICAgaWYgKCFzaG93T3JpZ2luYWxTdGFja1RyYWNlKSB7XG4gICAgICAgICAgY29weVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrVHJhY2VFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uRG9uZShvblRpbWVvdXQoZXJyb3IpLCBudWxsKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gd2FpdEZvcldyYXBwZXIoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgLy8gY3JlYXRlIHRoZSBlcnJvciBoZXJlIHNvIGl0cyBzdGFjayB0cmFjZSBpcyBhcyBjbG9zZSB0byB0aGVcbiAgLy8gY2FsbGluZyBjb2RlIGFzIHBvc3NpYmxlXG4gIGNvbnN0IHN0YWNrVHJhY2VFcnJvciA9IG5ldyBFcnJvcignU1RBQ0tfVFJBQ0VfTUVTU0FHRScpO1xuICByZXR1cm4gKDAsIF9jb25maWcuZ2V0Q29uZmlnKSgpLmFzeW5jV3JhcHBlcigoKSA9PiB3YWl0Rm9yKGNhbGxiYWNrLCB7XG4gICAgc3RhY2tUcmFjZUVycm9yLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkpO1xufVxuXG4vKlxuZXNsaW50XG4gIG1heC1saW5lcy1wZXItZnVuY3Rpb246IFtcImVycm9yXCIsIHtcIm1heFwiOiAyMDB9XSxcbiovIl0sInZlcnNpb24iOjN9