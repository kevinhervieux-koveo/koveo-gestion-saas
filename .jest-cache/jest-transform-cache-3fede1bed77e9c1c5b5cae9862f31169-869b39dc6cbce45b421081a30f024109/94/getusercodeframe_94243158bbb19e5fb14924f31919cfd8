5fbeebd3a76d8668333c7ad4de8d6616
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getUserCodeFrame = getUserCodeFrame;
// We try to load node dependencies
let picocolors = null;
let readFileSync = null;
let codeFrameColumns = null;
try {
    const nodeRequire = module && module.require;
    readFileSync = nodeRequire.call(module, 'fs').readFileSync;
    codeFrameColumns = nodeRequire.call(module, '@babel/code-frame').codeFrameColumns;
    picocolors = nodeRequire.call(module, 'picocolors');
}
catch {
    // We're in a browser environment
}
// frame has the form "at myMethod (location/to/my/file.js:10:2)"
function getCodeFrame(frame) {
    const locationStart = frame.indexOf('(') + 1;
    const locationEnd = frame.indexOf(')');
    const frameLocation = frame.slice(locationStart, locationEnd);
    const frameLocationElements = frameLocation.split(':');
    const [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];
    let rawFileContents = '';
    try {
        rawFileContents = readFileSync(filename, 'utf-8');
    }
    catch {
        return '';
    }
    const codeFrame = codeFrameColumns(rawFileContents, {
        start: {
            line,
            column
        }
    }, {
        highlightCode: true,
        linesBelow: 0
    });
    return `${picocolors.dim(frameLocation)}\n${codeFrame}\n`;
}
function getUserCodeFrame() {
    // If we couldn't load dependencies, we can't generate the user trace
    /* istanbul ignore next */
    if (!readFileSync || !codeFrameColumns) {
        return '';
    }
    const err = new Error();
    const firstClientCodeFrame = err.stack.split('\n').slice(1) // Remove first line which has the form "Error: TypeError"
        .find(frame => !frame.includes('node_modules/')); // Ignore frames from 3rd party libraries
    return getCodeFrame(firstClientCodeFrame);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9nZXQtdXNlci1jb2RlLWZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQztBQUViLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRTtJQUMzQyxLQUFLLEVBQUUsSUFBSTtDQUNaLENBQUMsQ0FBQztBQUNILE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUM1QyxtQ0FBbUM7QUFDbkMsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3RCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQztBQUN4QixJQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQztBQUM1QixJQUFJLENBQUM7SUFDSCxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUM3QyxZQUFZLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDO0lBQzNELGdCQUFnQixHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLG1CQUFtQixDQUFDLENBQUMsZ0JBQWdCLENBQUM7SUFDbEYsVUFBVSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQ3RELENBQUM7QUFBQyxNQUFNLENBQUM7SUFDUCxpQ0FBaUM7QUFDbkMsQ0FBQztBQUVELGlFQUFpRTtBQUNqRSxTQUFTLFlBQVksQ0FBQyxLQUFLO0lBQ3pCLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzdDLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdkMsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDOUQsTUFBTSxxQkFBcUIsR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZELE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzVJLElBQUksZUFBZSxHQUFHLEVBQUUsQ0FBQztJQUN6QixJQUFJLENBQUM7UUFDSCxlQUFlLEdBQUcsWUFBWSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBQUMsTUFBTSxDQUFDO1FBQ1AsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBQ0QsTUFBTSxTQUFTLEdBQUcsZ0JBQWdCLENBQUMsZUFBZSxFQUFFO1FBQ2xELEtBQUssRUFBRTtZQUNMLElBQUk7WUFDSixNQUFNO1NBQ1A7S0FDRixFQUFFO1FBQ0QsYUFBYSxFQUFFLElBQUk7UUFDbkIsVUFBVSxFQUFFLENBQUM7S0FDZCxDQUFDLENBQUM7SUFDSCxPQUFPLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxTQUFTLElBQUksQ0FBQztBQUM1RCxDQUFDO0FBQ0QsU0FBUyxnQkFBZ0I7SUFDdkIscUVBQXFFO0lBQ3JFLDBCQUEwQjtJQUMxQixJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN2QyxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFDRCxNQUFNLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQ3hCLE1BQU0sb0JBQW9CLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLDBEQUEwRDtTQUNySCxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLHlDQUF5QztJQUUzRixPQUFPLFlBQVksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQzVDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9nZXQtdXNlci1jb2RlLWZyYW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRVc2VyQ29kZUZyYW1lID0gZ2V0VXNlckNvZGVGcmFtZTtcbi8vIFdlIHRyeSB0byBsb2FkIG5vZGUgZGVwZW5kZW5jaWVzXG5sZXQgcGljb2NvbG9ycyA9IG51bGw7XG5sZXQgcmVhZEZpbGVTeW5jID0gbnVsbDtcbmxldCBjb2RlRnJhbWVDb2x1bW5zID0gbnVsbDtcbnRyeSB7XG4gIGNvbnN0IG5vZGVSZXF1aXJlID0gbW9kdWxlICYmIG1vZHVsZS5yZXF1aXJlO1xuICByZWFkRmlsZVN5bmMgPSBub2RlUmVxdWlyZS5jYWxsKG1vZHVsZSwgJ2ZzJykucmVhZEZpbGVTeW5jO1xuICBjb2RlRnJhbWVDb2x1bW5zID0gbm9kZVJlcXVpcmUuY2FsbChtb2R1bGUsICdAYmFiZWwvY29kZS1mcmFtZScpLmNvZGVGcmFtZUNvbHVtbnM7XG4gIHBpY29jb2xvcnMgPSBub2RlUmVxdWlyZS5jYWxsKG1vZHVsZSwgJ3BpY29jb2xvcnMnKTtcbn0gY2F0Y2gge1xuICAvLyBXZSdyZSBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbn1cblxuLy8gZnJhbWUgaGFzIHRoZSBmb3JtIFwiYXQgbXlNZXRob2QgKGxvY2F0aW9uL3RvL215L2ZpbGUuanM6MTA6MilcIlxuZnVuY3Rpb24gZ2V0Q29kZUZyYW1lKGZyYW1lKSB7XG4gIGNvbnN0IGxvY2F0aW9uU3RhcnQgPSBmcmFtZS5pbmRleE9mKCcoJykgKyAxO1xuICBjb25zdCBsb2NhdGlvbkVuZCA9IGZyYW1lLmluZGV4T2YoJyknKTtcbiAgY29uc3QgZnJhbWVMb2NhdGlvbiA9IGZyYW1lLnNsaWNlKGxvY2F0aW9uU3RhcnQsIGxvY2F0aW9uRW5kKTtcbiAgY29uc3QgZnJhbWVMb2NhdGlvbkVsZW1lbnRzID0gZnJhbWVMb2NhdGlvbi5zcGxpdCgnOicpO1xuICBjb25zdCBbZmlsZW5hbWUsIGxpbmUsIGNvbHVtbl0gPSBbZnJhbWVMb2NhdGlvbkVsZW1lbnRzWzBdLCBwYXJzZUludChmcmFtZUxvY2F0aW9uRWxlbWVudHNbMV0sIDEwKSwgcGFyc2VJbnQoZnJhbWVMb2NhdGlvbkVsZW1lbnRzWzJdLCAxMCldO1xuICBsZXQgcmF3RmlsZUNvbnRlbnRzID0gJyc7XG4gIHRyeSB7XG4gICAgcmF3RmlsZUNvbnRlbnRzID0gcmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmLTgnKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGNvZGVGcmFtZSA9IGNvZGVGcmFtZUNvbHVtbnMocmF3RmlsZUNvbnRlbnRzLCB7XG4gICAgc3RhcnQ6IHtcbiAgICAgIGxpbmUsXG4gICAgICBjb2x1bW5cbiAgICB9XG4gIH0sIHtcbiAgICBoaWdobGlnaHRDb2RlOiB0cnVlLFxuICAgIGxpbmVzQmVsb3c6IDBcbiAgfSk7XG4gIHJldHVybiBgJHtwaWNvY29sb3JzLmRpbShmcmFtZUxvY2F0aW9uKX1cXG4ke2NvZGVGcmFtZX1cXG5gO1xufVxuZnVuY3Rpb24gZ2V0VXNlckNvZGVGcmFtZSgpIHtcbiAgLy8gSWYgd2UgY291bGRuJ3QgbG9hZCBkZXBlbmRlbmNpZXMsIHdlIGNhbid0IGdlbmVyYXRlIHRoZSB1c2VyIHRyYWNlXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghcmVhZEZpbGVTeW5jIHx8ICFjb2RlRnJhbWVDb2x1bW5zKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcigpO1xuICBjb25zdCBmaXJzdENsaWVudENvZGVGcmFtZSA9IGVyci5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkgLy8gUmVtb3ZlIGZpcnN0IGxpbmUgd2hpY2ggaGFzIHRoZSBmb3JtIFwiRXJyb3I6IFR5cGVFcnJvclwiXG4gIC5maW5kKGZyYW1lID0+ICFmcmFtZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzLycpKTsgLy8gSWdub3JlIGZyYW1lcyBmcm9tIDNyZCBwYXJ0eSBsaWJyYXJpZXNcblxuICByZXR1cm4gZ2V0Q29kZUZyYW1lKGZpcnN0Q2xpZW50Q29kZUZyYW1lKTtcbn0iXSwidmVyc2lvbiI6M30=