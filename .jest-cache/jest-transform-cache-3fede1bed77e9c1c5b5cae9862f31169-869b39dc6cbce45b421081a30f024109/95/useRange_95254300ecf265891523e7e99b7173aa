8e0e8a176f7074bfd6a68b8b37fd7989
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRange = useRange;
const useControlledValue_js_1 = require("../helpers/useControlledValue.js");
const index_js_1 = require("../utils/index.js");
const rangeIncludesDate_js_1 = require("../utils/rangeIncludesDate.js");
/**
 * Hook to manage range selection in the DayPicker component.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns An object containing the selected range, a function to select a
 *   range, and a function to check if a date is within the range.
 */
function useRange(props, dateLib) {
    const { disabled, excludeDisabled, selected: initiallySelected, required, onSelect, } = props;
    const [internallySelected, setSelected] = (0, useControlledValue_js_1.useControlledValue)(initiallySelected, onSelect ? initiallySelected : undefined);
    const selected = !onSelect ? internallySelected : initiallySelected;
    const isSelected = (date) => selected && (0, rangeIncludesDate_js_1.rangeIncludesDate)(selected, date, false, dateLib);
    const select = (triggerDate, modifiers, e) => {
        const { min, max } = props;
        const newRange = triggerDate
            ? (0, index_js_1.addToRange)(triggerDate, selected, min, max, required, dateLib)
            : undefined;
        if (excludeDisabled && disabled && newRange?.from && newRange.to) {
            if ((0, index_js_1.rangeContainsModifiers)({ from: newRange.from, to: newRange.to }, disabled, dateLib)) {
                // if a disabled days is found, the range is reset
                newRange.from = triggerDate;
                newRange.to = undefined;
            }
        }
        if (!onSelect) {
            setSelected(newRange);
        }
        onSelect?.(newRange, triggerDate, modifiers, e);
        return newRange;
    };
    return {
        selected,
        select,
        isSelected,
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcmVhY3QtZGF5LXBpY2tlci9kaXN0L2Nqcy9zZWxlY3Rpb24vdXNlUmFuZ2UuanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDO0FBQ2IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7QUFDOUQsT0FBTyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDNUIsTUFBTSx1QkFBdUIsR0FBRyxPQUFPLENBQUMsa0NBQWtDLENBQUMsQ0FBQztBQUM1RSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUNoRCxNQUFNLHNCQUFzQixHQUFHLE9BQU8sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBQ3hFOzs7Ozs7OztHQVFHO0FBQ0gsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLE9BQU87SUFDNUIsTUFBTSxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLFFBQVEsRUFBRSxRQUFRLEdBQUcsR0FBRyxLQUFLLENBQUM7SUFDOUYsTUFBTSxDQUFDLGtCQUFrQixFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLHVCQUF1QixDQUFDLGtCQUFrQixDQUFDLENBQUMsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkosTUFBTSxRQUFRLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQztJQUNwRSxNQUFNLFVBQVUsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxFQUFFLHNCQUFzQixDQUFDLGlCQUFpQixDQUFDLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDdkgsTUFBTSxNQUFNLEdBQUcsQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3pDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFDO1FBQzNCLE1BQU0sUUFBUSxHQUFHLFdBQVc7WUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxXQUFXLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQztZQUNoRixDQUFDLENBQUMsU0FBUyxDQUFDO1FBQ2hCLElBQUksZUFBZSxJQUFJLFFBQVEsSUFBSSxRQUFRLEVBQUUsSUFBSSxJQUFJLFFBQVEsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMvRCxJQUFJLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQztnQkFDdEcsa0RBQWtEO2dCQUNsRCxRQUFRLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQztnQkFDNUIsUUFBUSxDQUFDLEVBQUUsR0FBRyxTQUFTLENBQUM7WUFDNUIsQ0FBQztRQUNMLENBQUM7UUFDRCxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDWixXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDMUIsQ0FBQztRQUNELFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2hELE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUMsQ0FBQztJQUNGLE9BQU87UUFDSCxRQUFRO1FBQ1IsTUFBTTtRQUNOLFVBQVU7S0FDYixDQUFDO0FBQ04sQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9yZWFjdC1kYXktcGlja2VyL2Rpc3QvY2pzL3NlbGVjdGlvbi91c2VSYW5nZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXNlUmFuZ2UgPSB1c2VSYW5nZTtcbmNvbnN0IHVzZUNvbnRyb2xsZWRWYWx1ZV9qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXNlQ29udHJvbGxlZFZhbHVlLmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHJhbmdlSW5jbHVkZXNEYXRlX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvcmFuZ2VJbmNsdWRlc0RhdGUuanNcIik7XG4vKipcbiAqIEhvb2sgdG8gbWFuYWdlIHJhbmdlIHNlbGVjdGlvbiBpbiB0aGUgRGF5UGlja2VyIGNvbXBvbmVudC5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIERheVBpY2tlciBwcm9wcy5cbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBEYXlQaWNrZXIgcHJvcHMuXG4gKiBAcGFyYW0gZGF0ZUxpYiAtIFRoZSBkYXRlIHV0aWxpdHkgbGlicmFyeSBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzZWxlY3RlZCByYW5nZSwgYSBmdW5jdGlvbiB0byBzZWxlY3QgYVxuICogICByYW5nZSwgYW5kIGEgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBkYXRlIGlzIHdpdGhpbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHVzZVJhbmdlKHByb3BzLCBkYXRlTGliKSB7XG4gICAgY29uc3QgeyBkaXNhYmxlZCwgZXhjbHVkZURpc2FibGVkLCBzZWxlY3RlZDogaW5pdGlhbGx5U2VsZWN0ZWQsIHJlcXVpcmVkLCBvblNlbGVjdCwgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtpbnRlcm5hbGx5U2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9ICgwLCB1c2VDb250cm9sbGVkVmFsdWVfanNfMS51c2VDb250cm9sbGVkVmFsdWUpKGluaXRpYWxseVNlbGVjdGVkLCBvblNlbGVjdCA/IGluaXRpYWxseVNlbGVjdGVkIDogdW5kZWZpbmVkKTtcbiAgICBjb25zdCBzZWxlY3RlZCA9ICFvblNlbGVjdCA/IGludGVybmFsbHlTZWxlY3RlZCA6IGluaXRpYWxseVNlbGVjdGVkO1xuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSAoZGF0ZSkgPT4gc2VsZWN0ZWQgJiYgKDAsIHJhbmdlSW5jbHVkZXNEYXRlX2pzXzEucmFuZ2VJbmNsdWRlc0RhdGUpKHNlbGVjdGVkLCBkYXRlLCBmYWxzZSwgZGF0ZUxpYik7XG4gICAgY29uc3Qgc2VsZWN0ID0gKHRyaWdnZXJEYXRlLCBtb2RpZmllcnMsIGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IG5ld1JhbmdlID0gdHJpZ2dlckRhdGVcbiAgICAgICAgICAgID8gKDAsIGluZGV4X2pzXzEuYWRkVG9SYW5nZSkodHJpZ2dlckRhdGUsIHNlbGVjdGVkLCBtaW4sIG1heCwgcmVxdWlyZWQsIGRhdGVMaWIpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGV4Y2x1ZGVEaXNhYmxlZCAmJiBkaXNhYmxlZCAmJiBuZXdSYW5nZT8uZnJvbSAmJiBuZXdSYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc18xLnJhbmdlQ29udGFpbnNNb2RpZmllcnMpKHsgZnJvbTogbmV3UmFuZ2UuZnJvbSwgdG86IG5ld1JhbmdlLnRvIH0sIGRpc2FibGVkLCBkYXRlTGliKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgZGlzYWJsZWQgZGF5cyBpcyBmb3VuZCwgdGhlIHJhbmdlIGlzIHJlc2V0XG4gICAgICAgICAgICAgICAgbmV3UmFuZ2UuZnJvbSA9IHRyaWdnZXJEYXRlO1xuICAgICAgICAgICAgICAgIG5ld1JhbmdlLnRvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb25TZWxlY3QpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKG5ld1JhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBvblNlbGVjdD8uKG5ld1JhbmdlLCB0cmlnZ2VyRGF0ZSwgbW9kaWZpZXJzLCBlKTtcbiAgICAgICAgcmV0dXJuIG5ld1JhbmdlO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIHNlbGVjdCxcbiAgICAgICAgaXNTZWxlY3RlZCxcbiAgICB9O1xufVxuIl0sInZlcnNpb24iOjN9