ccd3fb94abe4c2d672ab56c64ac177c8
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.reducer = void 0;
exports.useToast = useToast;
exports.toast = toast;
const React = __importStar(require("react"));
const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;
const actionTypes = {
    ADD_TOAST: 'ADD_TOAST',
    UPDATE_TOAST: 'UPDATE_TOAST',
    DISMISS_TOAST: 'DISMISS_TOAST',
    REMOVE_TOAST: 'REMOVE_TOAST',
};
let count = 0;
/**
 * Generates a unique identifier for toast notifications.
 * Uses an incrementing counter with overflow protection to ensure uniqueness.
 *
 * @returns {string} Unique string identifier for the toast.
 * @example
 * ```typescript
 * const id = genId(); // Returns '1', '2', '3', etc.
 * ```
 */
/**
 * GenId function.
 * @returns Function result.
 */
function genId() {
    count = (count + 1) % Number.MAX_SAFE_INTEGER;
    return count.toString();
}
const toastTimeouts = new Map();
const addToRemoveQueue = (toastId) => {
    if (toastTimeouts.has(toastId)) {
        return;
    }
    const timeout = setTimeout(() => {
        toastTimeouts.delete(toastId);
        dispatch({
            type: 'REMOVE_TOAST',
            toastId: toastId,
        });
    }, TOAST_REMOVE_DELAY);
    toastTimeouts.set(toastId, timeout);
};
/**
 * Reduce .
 * @param state - State parameter.
 * @param action - Action parameter.
 * @returns State result.
 */
/**
 * Reduce .
 * @param state - State parameter.
 * @param action - Action parameter.
 * @returns State result.
 */
const reducer = (state, action) => {
    /**
     * Switch function.
     * @param action.type - Action.type parameter.
     */
    switch (action.type) {
        case 'ADD_TOAST':
            return {
                ...state,
                toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
            };
        case 'UPDATE_TOAST':
            return {
                ...state,
                toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
            };
        case 'DISMISS_TOAST': {
            const { toastId } = action;
            // ! Side effects ! - This could be extracted into a dismissToast() action,
            // but I'll keep it here for simplicity
            if (toastId) {
                addToRemoveQueue(toastId);
            }
            else {
                state.toasts.forEach((toast) => {
                    addToRemoveQueue(toast.id);
                });
            }
            return {
                ...state,
                toasts: state.toasts.map((t) => t.id === toastId || toastId === undefined
                    ? {
                        ...t,
                        open: false,
                    }
                    : t),
            };
        }
        case 'REMOVE_TOAST' /**
         * If function.
         * @param action.toastId === undefined - action.toastId === undefined parameter.
         */:
            if (action.toastId === undefined) {
                return {
                    ...state,
                    toasts: [],
                };
            }
            return {
                ...state,
                toasts: state.toasts.filter((t) => t.id !== action.toastId),
            };
    }
};
exports.reducer = reducer;
const listeners = [];
let memoryState = { toasts: [] };
/**
 * Dispatches an action to update the toast state and notifies all listeners.
 * Central state management function for the toast system.
 *
 * @param {Action} action - The action object containing type and payload data.
 * @example
 * ```typescript
 * dispatch({ type: 'ADD_TOAST', toast: newToast });
 * dispatch({ type: 'DISMISS_TOAST', toastId: 'toast-1' });
 * ```
 */
/**
 * Dispatch function.
 * @param action
 * @returns Function result.
 */
function dispatch(action) {
    memoryState = (0, exports.reducer)(memoryState, action);
    listeners.forEach((listener) => {
        listener(memoryState);
    });
}
/**
 * Creates and displays a new toast notification.
 * Automatically generates a unique ID and provides update/dismiss functions.
 *
 * @param {Toast} props - Toast configuration including title, description, and other display options.
 * @returns {object} Object containing toast ID and control functions (dismiss, update).
 * @example
 * ```typescript
 * const { dismiss, update } = toast({
 *   title: 'Success',
 *   description: 'Operation completed successfully'
 * });
 *
 * // Later dismiss the toast
 * dismiss();
 *
 * // Or update its content
 * update({ title: 'Updated Title' });
 * ```
 */
/**
 * Toast function.
 * @param root0
 * @returns Function result.
 */
function toast({ ...props }) {
    const id = genId();
    const update = (_props) => dispatch({
        type: 'UPDATE_TOAST',
        toast: { ...props, id },
    });
    const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id });
    dispatch({
        type: 'ADD_TOAST',
        toast: {
            ...props,
            id,
            open: true,
            onOpenChange: (open) => {
                /**
                 * If function.
                 * @param !open - !open parameter.
                 */ /**
                * If function.
                * @param !open - !open parameter.
                */
                if (!open) {
                    dismiss();
                }
            },
        },
    });
    return {
        id: id,
        dismiss,
        update,
    };
}
/**
 * React hook for managing toast notifications in components.
 * Provides access to toast state and functions for creating and dismissing toasts.
 *
 * @returns {object} Toast state and control functions.
 * @returns {ToasterToast[]} Returns.toasts - Array of current active toasts.
 * @returns {Function} Returns.toast - Function to create new toast notifications.
 * @returns {Function} Returns.dismiss - Function to dismiss specific or all toasts.
 * @example
 * ```typescript
 * function MyComponent() {
 *   const { toast, dismiss, toasts } = useToast();
 *
 *   const showSuccess = () => {
 *     toast({
 *       title: 'Success!',
 *       description: 'Your changes have been saved.'
 *     });
 *   };
 *
 *   return (
 *     <button onClick={showSuccess}>Save Changes</button>
 *   );
 * }
 * ```
 */
/**
 * UseToast function.
 * @returns Function result.
 */
function useToast() {
    const [state, setState] = React.useState(memoryState);
    React.useEffect(() => {
        listeners.push(setState);
        return () => {
            const index = listeners.indexOf(setState); /**
             * If function.
             * @param index > -1 - index > -1 parameter.
             */ /**
            * If function.
            * @param index > -1 - index > -1 parameter.
            */
            if (index > -1) {
                listeners.splice(index, 1);
            }
        };
    }, [state]);
    return {
        ...state,
        toast,
        dismiss: (toastId) => dispatch({ type: 'DISMISS_TOAST', toastId }),
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9jbGllbnQvc3JjL2hvb2tzL3VzZS10b2FzdC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvV1MsNEJBQVE7QUFBRSxzQkFBSztBQXBXeEIsNkNBQStCO0FBSS9CLE1BQU0sV0FBVyxHQUFHLENBQUMsQ0FBQztBQUN0QixNQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQztBQWFuQyxNQUFNLFdBQVcsR0FBRztJQUNsQixTQUFTLEVBQUUsV0FBVztJQUN0QixZQUFZLEVBQUUsY0FBYztJQUM1QixhQUFhLEVBQUUsZUFBZTtJQUM5QixZQUFZLEVBQUUsY0FBYztDQUNwQixDQUFDO0FBRVgsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBRWQ7Ozs7Ozs7OztHQVNHO0FBQ0g7OztHQUdHO0FBQ0gsU0FNQSxLQUFLO0lBQ0gsS0FBSyxHQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztJQUM5QyxPQUFPLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUMxQixDQUFDO0FBc0NELE1BQU0sYUFBYSxHQUFHLElBQUksR0FBRyxFQUF5QyxDQUFDO0FBRXZFLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxPQUFlLEVBQUUsRUFBRTtJQUMzQyxJQUFJLGFBQWEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUMvQixPQUFPO0lBQ1QsQ0FBQztJQUVELE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDOUIsYUFBYSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QixRQUFRLENBQUM7WUFDUCxJQUFJLEVBQUUsY0FBYztZQUNwQixPQUFPLEVBQUUsT0FBTztTQUNqQixDQUFDLENBQUM7SUFDTCxDQUFDLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUV2QixhQUFhLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFP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QUFLLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDOzs7ZUFHeEMsQ0FBQzs7O2NBR0Q7WUFFSCxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNmLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzdCLENBQUM7UUFDSCxDQUFDLENBQUM7SUFDSixDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRVosT0FBTztRQUNMLEdBQUcsS0FBSztRQUNSLEtBQUs7UUFDTCxPQUFPLEVBQUUsQ0FBQyxPQUFnQixFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxDQUFDO0tBQzVFLENBQUM7QUFDSixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvY2xpZW50L3NyYy9ob29rcy91c2UtdG9hc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdHlwZSB7IFRvYXN0QWN0aW9uRWxlbWVudCwgVG9hc3RQcm9wcyB9IGZyb20gJ0AvY29tcG9uZW50cy91aS90b2FzdCc7XG5cbmNvbnN0IFRPQVNUX0xJTUlUID0gMTtcbmNvbnN0IFRPQVNUX1JFTU9WRV9ERUxBWSA9IDEwMDAwMDA7XG5cbi8qKlxuICogRXh0ZW5kZWQgdG9hc3QgcHJvcGVydGllcyB0aGF0IGluY2x1ZGUgYWRkaXRpb25hbCBVSSBzdGF0ZSBhbmQgYWN0aW9ucy5cbiAqIENvbWJpbmVzIGJhc2UgVG9hc3RQcm9wcyB3aXRoIHVuaXF1ZSBpZGVudGlmaWVyIGFuZCBSZWFjdCBub2RlIGNvbnRlbnQuXG4gKi9cbnR5cGUgVG9hc3RlclRvYXN0ID0gVG9hc3RQcm9wcyAmIHtcbiAgaWQ6IHN0cmluZztcbiAgdGl0bGU/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGRlc2NyaXB0aW9uPzogUmVhY3QuUmVhY3ROb2RlO1xuICBhY3Rpb24/OiBUb2FzdEFjdGlvbkVsZW1lbnQ7XG59O1xuXG5jb25zdCBhY3Rpb25UeXBlcyA9IHtcbiAgQUREX1RPQVNUOiAnQUREX1RPQVNUJyxcbiAgVVBEQVRFX1RPQVNUOiAnVVBEQVRFX1RPQVNUJyxcbiAgRElTTUlTU19UT0FTVDogJ0RJU01JU1NfVE9BU1QnLFxuICBSRU1PVkVfVE9BU1Q6ICdSRU1PVkVfVE9BU1QnLFxufSBhcyBjb25zdDtcblxubGV0IGNvdW50ID0gMDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdG9hc3Qgbm90aWZpY2F0aW9ucy5cbiAqIFVzZXMgYW4gaW5jcmVtZW50aW5nIGNvdW50ZXIgd2l0aCBvdmVyZmxvdyBwcm90ZWN0aW9uIHRvIGVuc3VyZSB1bmlxdWVuZXNzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVuaXF1ZSBzdHJpbmcgaWRlbnRpZmllciBmb3IgdGhlIHRvYXN0LlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGlkID0gZ2VuSWQoKTsgLy8gUmV0dXJucyAnMScsICcyJywgJzMnLCBldGMuXG4gKiBgYGBcbiAqL1xuLyoqXG4gKiBHZW5JZCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIEZ1bmN0aW9uIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gLyoqXG4gKiBHZW4gaWQgZnVuY3Rpb24uXG4gKi8gLyoqXG4gKiBHZW4gaWQgZnVuY3Rpb24uXG4gKi9cblxuZ2VuSWQoKSB7XG4gIGNvdW50ID0gKGNvdW50ICsgMSkgJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgcmV0dXJuIGNvdW50LnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVHlwZSBkZWZpbml0aW9uIGZvciBhbGwgcG9zc2libGUgdG9hc3QgYWN0aW9uIHR5cGVzLlxuICogRGVyaXZlZCBmcm9tIHRoZSBhY3Rpb25UeXBlcyBjb25zdGFudCBvYmplY3QuXG4gKi9cbnR5cGUgQWN0aW9uVHlwZSA9IHR5cGVvZiBhY3Rpb25UeXBlcztcblxuLyoqXG4gKiBVbmlvbiB0eXBlIGRlZmluaW5nIGFsbCBwb3NzaWJsZSBhY3Rpb25zIHRoYXQgY2FuIGJlIGRpc3BhdGNoZWQgdG8gdGhlIHRvYXN0IHJlZHVjZXIuXG4gKiBFYWNoIGFjdGlvbiB0eXBlIGhhcyBzcGVjaWZpYyBwYXlsb2FkIHJlcXVpcmVtZW50cyBmb3IgbWFuYWdpbmcgdG9hc3Qgc3RhdGUuXG4gKi9cbnR5cGUgQWN0aW9uID1cbiAgfCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlWydBRERfVE9BU1QnXTtcbiAgICAgIHRvYXN0OiBUb2FzdGVyVG9hc3Q7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVbJ1VQREFURV9UT0FTVCddO1xuICAgICAgdG9hc3Q6IFBhcnRpYWw8VG9hc3RlclRvYXN0PjtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZVsnRElTTUlTU19UT0FTVCddO1xuICAgICAgdG9hc3RJZD86IFRvYXN0ZXJUb2FzdFsnaWQnXTtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZVsnUkVNT1ZFX1RPQVNUJ107XG4gICAgICB0b2FzdElkPzogVG9hc3RlclRvYXN0WydpZCddO1xuICAgIH07XG5cbi8qKlxuICogQXBwbGljYXRpb24gc3RhdGUgaW50ZXJmYWNlIGZvciB0aGUgdG9hc3QgbWFuYWdlbWVudCBzeXN0ZW0uXG4gKiBDb250YWlucyB0aGUgYXJyYXkgb2YgYWN0aXZlIHRvYXN0cyBiZWluZyBkaXNwbGF5ZWQuXG4gKi9cbmludGVyZmFjZSBTdGF0ZSB7XG4gIHRvYXN0czogVG9hc3RlclRvYXN0W107XG59XG5cbmNvbnN0IHRvYXN0VGltZW91dHMgPSBuZXcgTWFwPHN0cmluZywgUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4+KCk7XG5cbmNvbnN0IGFkZFRvUmVtb3ZlUXVldWUgPSAodG9hc3RJZDogc3RyaW5nKSA9PiB7XG4gIGlmICh0b2FzdFRpbWVvdXRzLmhhcyh0b2FzdElkKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0b2FzdFRpbWVvdXRzLmRlbGV0ZSh0b2FzdElkKTtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnUkVNT1ZFX1RPQVNUJyxcbiAgICAgIHRvYXN0SWQ6IHRvYXN0SWQsXG4gICAgfSk7XG4gIH0sIFRPQVNUX1JFTU9WRV9ERUxBWSk7XG5cbiAgdG9hc3RUaW1lb3V0cy5zZXQodG9hc3RJZCwgdGltZW91dCk7XG59O1xuXG4vKipcbiAqIFJlZHVjZSAuXG4gKiBAcGFyYW0gc3RhdGUgLSBTdGF0ZSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIFN0YXRlIHJlc3VsdC5cbiAqL1xuLyoqXG4gKiBSZWR1Y2UgLlxuICogQHBhcmFtIHN0YXRlIC0gU3RhdGUgcGFyYW1ldGVyLlxuICogQHBhcmFtIGFjdGlvbiAtIEFjdGlvbiBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyBTdGF0ZSByZXN1bHQuXG4gKi9cbmV4cG9ydCBjb25zdCByZWR1Y2VyID0gKHN0YXRlOiBTdGF0ZSwgYWN0aW9uOiBBY3Rpb24pOiBTdGF0ZSA9PiB7XG4gIC8qKlxuICAgKiBTd2l0Y2ggZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBhY3Rpb24udHlwZSAtIEFjdGlvbi50eXBlIHBhcmFtZXRlci5cbiAgICovXG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0FERF9UT0FTVCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdG9hc3RzOiBbYWN0aW9uLnRvYXN0LCAuLi5zdGF0ZS50b2FzdHNdLnNsaWNlKDAsIFRPQVNUX0xJTUlUKSxcbiAgICAgIH07XG5cbiAgICBjYXNlICdVUERBVEVfVE9BU1QnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHRvYXN0czogc3RhdGUudG9hc3RzLm1hcCgodCkgPT4gKHQuaWQgPT09IGFjdGlvbi50b2FzdC5pZCA/IHsgLi4udCwgLi4uYWN0aW9uLnRvYXN0IH0gOiB0KSksXG4gICAgICB9O1xuXG4gICAgY2FzZSAnRElTTUlTU19UT0FTVCc6IHtcbiAgICAgIGNvbnN0IHsgdG9hc3RJZCB9ID0gYWN0aW9uO1xuXG4gICAgICAvLyAhIFNpZGUgZWZmZWN0cyAhIC0gVGhpcyBjb3VsZCBiZSBleHRyYWN0ZWQgaW50byBhIGRpc21pc3NUb2FzdCgpIGFjdGlvbixcbiAgICAgIC8vIGJ1dCBJJ2xsIGtlZXAgaXQgaGVyZSBmb3Igc2ltcGxpY2l0eVxuXG4gICAgICBpZiAodG9hc3RJZCkge1xuICAgICAgICBhZGRUb1JlbW92ZVF1ZXVlKHRvYXN0SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudG9hc3RzLmZvckVhY2goKHRvYXN0KSA9PiB7XG4gICAgICAgICAgYWRkVG9SZW1vdmVRdWV1ZSh0b2FzdC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdG9hc3RzOiBzdGF0ZS50b2FzdHMubWFwKCh0KSA9PlxuICAgICAgICAgIHQuaWQgPT09IHRvYXN0SWQgfHwgdG9hc3RJZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgICAgIG9wZW46IGZhbHNlLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHRcbiAgICAgICAgKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgJ1JFTU9WRV9UT0FTVCcgLyoqXG4gICAgICogSWYgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGFjdGlvbi50b2FzdElkID09PSB1bmRlZmluZWQgLSBhY3Rpb24udG9hc3RJZCA9PT0gdW5kZWZpbmVkIHBhcmFtZXRlci5cbiAgICAgKi86XG4gICAgICBpZiAoYWN0aW9uLnRvYXN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHRvYXN0czogW10sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdG9hc3RzOiBzdGF0ZS50b2FzdHMuZmlsdGVyKCh0KSA9PiB0LmlkICE9PSBhY3Rpb24udG9hc3RJZCksXG4gICAgICB9O1xuICB9XG59O1xuXG5jb25zdCBsaXN0ZW5lcnM6IEFycmF5PChzdGF0ZTogU3RhdGUpID0+IHZvaWQ+ID0gW107XG5cbmxldCBtZW1vcnlTdGF0ZTogU3RhdGUgPSB7IHRvYXN0czogW10gfTtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGFjdGlvbiB0byB1cGRhdGUgdGhlIHRvYXN0IHN0YXRlIGFuZCBub3RpZmllcyBhbGwgbGlzdGVuZXJzLlxuICogQ2VudHJhbCBzdGF0ZSBtYW5hZ2VtZW50IGZ1bmN0aW9uIGZvciB0aGUgdG9hc3Qgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7QWN0aW9ufSBhY3Rpb24gLSBUaGUgYWN0aW9uIG9iamVjdCBjb250YWluaW5nIHR5cGUgYW5kIHBheWxvYWQgZGF0YS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBkaXNwYXRjaCh7IHR5cGU6ICdBRERfVE9BU1QnLCB0b2FzdDogbmV3VG9hc3QgfSk7XG4gKiBkaXNwYXRjaCh7IHR5cGU6ICdESVNNSVNTX1RPQVNUJywgdG9hc3RJZDogJ3RvYXN0LTEnIH0pO1xuICogYGBgXG4gKi9cbi8qKlxuICogRGlzcGF0Y2ggZnVuY3Rpb24uXG4gKiBAcGFyYW0gYWN0aW9uXG4gKiBAcmV0dXJucyBGdW5jdGlvbiByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIC8qKlxuICogRGlzcGF0Y2ggZnVuY3Rpb24uXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHBhcmFtZXRlci5cbiAqLyAvKipcbiAqIERpc3BhdGNoIGZ1bmN0aW9uLlxuICogQHBhcmFtIGFjdGlvbiAtIEFjdGlvbiBwYXJhbWV0ZXIuXG4gKi9cblxuZGlzcGF0Y2goYWN0aW9uOiBBY3Rpb24pIHtcbiAgbWVtb3J5U3RhdGUgPSByZWR1Y2VyKG1lbW9yeVN0YXRlLCBhY3Rpb24pO1xuICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcihtZW1vcnlTdGF0ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRvYXN0IGNvbmZpZ3VyYXRpb24gdHlwZSB3aXRob3V0IHRoZSBhdXRvLWdlbmVyYXRlZCBJRCBmaWVsZC5cbiAqIFVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdG9hc3RzIHdoZXJlIElEIHdpbGwgYmUgYXNzaWduZWQgYXV0b21hdGljYWxseS5cbiAqL1xudHlwZSBUb2FzdCA9IE9taXQ8VG9hc3RlclRvYXN0LCAnaWQnPjtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBkaXNwbGF5cyBhIG5ldyB0b2FzdCBub3RpZmljYXRpb24uXG4gKiBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBhIHVuaXF1ZSBJRCBhbmQgcHJvdmlkZXMgdXBkYXRlL2Rpc21pc3MgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7VG9hc3R9IHByb3BzIC0gVG9hc3QgY29uZmlndXJhdGlvbiBpbmNsdWRpbmcgdGl0bGUsIGRlc2NyaXB0aW9uLCBhbmQgb3RoZXIgZGlzcGxheSBvcHRpb25zLlxuICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdG9hc3QgSUQgYW5kIGNvbnRyb2wgZnVuY3Rpb25zIChkaXNtaXNzLCB1cGRhdGUpLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHsgZGlzbWlzcywgdXBkYXRlIH0gPSB0b2FzdCh7XG4gKiAgIHRpdGxlOiAnU3VjY2VzcycsXG4gKiAgIGRlc2NyaXB0aW9uOiAnT3BlcmF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknXG4gKiB9KTtcbiAqXG4gKiAvLyBMYXRlciBkaXNtaXNzIHRoZSB0b2FzdFxuICogZGlzbWlzcygpO1xuICpcbiAqIC8vIE9yIHVwZGF0ZSBpdHMgY29udGVudFxuICogdXBkYXRlKHsgdGl0bGU6ICdVcGRhdGVkIFRpdGxlJyB9KTtcbiAqIGBgYFxuICovXG4vKipcbiAqIFRvYXN0IGZ1bmN0aW9uLlxuICogQHBhcmFtIHJvb3QwXG4gKiBAcmV0dXJucyBGdW5jdGlvbiByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIC8qKlxuICogVG9hc3QgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyAuLi5wcm9wcyB9IC0geyAuLi5wcm9wcyB9IHBhcmFtZXRlci5cbiAqLyAvKipcbiAqIFRvYXN0IGZ1bmN0aW9uLlxuICogQHBhcmFtIHsgLi4ucHJvcHMgfSAtIHsgLi4ucHJvcHMgfSBwYXJhbWV0ZXIuXG4gKi9cblxudG9hc3QoeyAuLi5wcm9wcyB9OiBUb2FzdCkge1xuICBjb25zdCBpZCA9IGdlbklkKCk7XG5cbiAgY29uc3QgdXBkYXRlID0gKF9wcm9wczogVG9hc3RlclRvYXN0KSA9PlxuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdVUERBVEVfVE9BU1QnLFxuICAgICAgdG9hc3Q6IHsgLi4ucHJvcHMsIGlkIH0sXG4gICAgfSk7XG4gIGNvbnN0IGRpc21pc3MgPSAoKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdESVNNSVNTX1RPQVNUJywgdG9hc3RJZDogaWQgfSk7XG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6ICdBRERfVE9BU1QnLFxuICAgIHRvYXN0OiB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIGlkLFxuICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgIG9uT3BlbkNoYW5nZTogKG9wZW4pID0+IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gIW9wZW4gLSAhb3BlbiBwYXJhbWV0ZXIuXG4gICAgICAgICAqLyAvKipcbiAgICAgICAgICogSWYgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSAhb3BlbiAtICFvcGVuIHBhcmFtZXRlci5cbiAgICAgICAgICovXG5cbiAgICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgICAgZGlzbWlzcygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IGlkLFxuICAgIGRpc21pc3MsXG4gICAgdXBkYXRlLFxuICB9O1xufVxuXG4vKipcbiAqIFJlYWN0IGhvb2sgZm9yIG1hbmFnaW5nIHRvYXN0IG5vdGlmaWNhdGlvbnMgaW4gY29tcG9uZW50cy5cbiAqIFByb3ZpZGVzIGFjY2VzcyB0byB0b2FzdCBzdGF0ZSBhbmQgZnVuY3Rpb25zIGZvciBjcmVhdGluZyBhbmQgZGlzbWlzc2luZyB0b2FzdHMuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVG9hc3Qgc3RhdGUgYW5kIGNvbnRyb2wgZnVuY3Rpb25zLlxuICogQHJldHVybnMge1RvYXN0ZXJUb2FzdFtdfSBSZXR1cm5zLnRvYXN0cyAtIEFycmF5IG9mIGN1cnJlbnQgYWN0aXZlIHRvYXN0cy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucy50b2FzdCAtIEZ1bmN0aW9uIHRvIGNyZWF0ZSBuZXcgdG9hc3Qgbm90aWZpY2F0aW9ucy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucy5kaXNtaXNzIC0gRnVuY3Rpb24gdG8gZGlzbWlzcyBzcGVjaWZpYyBvciBhbGwgdG9hc3RzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGZ1bmN0aW9uIE15Q29tcG9uZW50KCkge1xuICogICBjb25zdCB7IHRvYXN0LCBkaXNtaXNzLCB0b2FzdHMgfSA9IHVzZVRvYXN0KCk7XG4gKlxuICogICBjb25zdCBzaG93U3VjY2VzcyA9ICgpID0+IHtcbiAqICAgICB0b2FzdCh7XG4gKiAgICAgICB0aXRsZTogJ1N1Y2Nlc3MhJyxcbiAqICAgICAgIGRlc2NyaXB0aW9uOiAnWW91ciBjaGFuZ2VzIGhhdmUgYmVlbiBzYXZlZC4nXG4gKiAgICAgfSk7XG4gKiAgIH07XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxidXR0b24gb25DbGljaz17c2hvd1N1Y2Nlc3N9PlNhdmUgQ2hhbmdlczwvYnV0dG9uPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbi8qKlxuICogVXNlVG9hc3QgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBGdW5jdGlvbiByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIC8qKlxuICogVXNlIHRvYXN0IGZ1bmN0aW9uLlxuICovIC8qKlxuICogVXNlIHRvYXN0IGZ1bmN0aW9uLlxuICovXG5cbnVzZVRvYXN0KCkge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlPFN0YXRlPihtZW1vcnlTdGF0ZSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsaXN0ZW5lcnMucHVzaChzZXRTdGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2Yoc2V0U3RhdGUpOyAvKipcbiAgICAgICAqIElmIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIGluZGV4ID4gLTEgLSBpbmRleCA+IC0xIHBhcmFtZXRlci5cbiAgICAgICAqLyAvKipcbiAgICAgICAqIElmIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIGluZGV4ID4gLTEgLSBpbmRleCA+IC0xIHBhcmFtZXRlci5cbiAgICAgICAqL1xuXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbc3RhdGVdKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIHRvYXN0LFxuICAgIGRpc21pc3M6ICh0b2FzdElkPzogc3RyaW5nKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdESVNNSVNTX1RPQVNUJywgdG9hc3RJZCB9KSxcbiAgfTtcbn1cblxuZXhwb3J0IHsgdXNlVG9hc3QsIHRvYXN0IH07XG4iXSwidmVyc2lvbiI6M30=