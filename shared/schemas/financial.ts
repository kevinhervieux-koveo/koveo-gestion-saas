import { sql } from 'drizzle-orm';
import {
  pgTable,
  text,
  timestamp,
  uuid,
  pgEnum,
  boolean,
  integer,
  decimal,
  date,
  jsonb,
} from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-zod';
import { z } from 'zod';
import { relations } from 'drizzle-orm';
import { users } from './core';
import { residences, buildings } from './property';

// Financial enums
export const billStatusEnum = pgEnum('bill_status', [
  'draft',
  'sent',
  'overdue',
  'paid',
  'cancelled',
]);

export const oldBillTypeEnum = pgEnum('old_bill_type', [
  'condo_fees',
  'special_assessment',
  'utility',
  'maintenance',
  'other',
]);

export const billCategoryEnum = pgEnum('bill_category', [
  'insurance',
  'maintenance',
  'salary',
  'utilities',
  'cleaning',
  'security',
  'landscaping',
  'professional_services',
  'administration',
  'repairs',
  'supplies',
  'taxes',
  'technology',
  'reserves',
  'other',
]);

export const paymentTypeEnum = pgEnum('payment_type', [
  'unique',
  'recurrent',
]);

export const schedulePaymentEnum = pgEnum('schedule_payment', [
  'weekly',
  'monthly',
  'quarterly',
  'yearly',
  'custom',
]);

export const moneyFlowTypeEnum = pgEnum('money_flow_type', [
  'income',
  'expense',
]);

export const moneyFlowCategoryEnum = pgEnum('money_flow_category', [
  'monthly_fees',
  'special_assessment',
  'late_fees',
  'parking_fees',
  'utility_reimbursement',
  'insurance_claim',
  'bill_payment',
  'maintenance_expense',
  'administrative_expense',
  'professional_services',
  'other_income',
  'other_expense',
]);

// Financial tables
/**
 * Money flow table for tracking all money movements in and out.
 * Includes monthly fees from residences and other financial transactions.
 */
export const moneyFlow = pgTable('money_flow', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  buildingId: uuid('building_id')
    .notNull()
    .references(() => buildings.id),
  residenceId: uuid('residence_id').references(() => residences.id), // Optional, for residence-specific transactions
  billId: uuid('bill_id').references(() => bills.id), // Optional, for bill-related transactions
  type: moneyFlowTypeEnum('type').notNull(), // income or expense
  category: moneyFlowCategoryEnum('category').notNull(),
  description: text('description').notNull(),
  amount: decimal('amount', { precision: 12, scale: 2 }).notNull(),
  transactionDate: date('transaction_date').notNull(),
  referenceNumber: text('reference_number'),
  notes: text('notes'),
  isReconciled: boolean('is_reconciled').default(false),
  reconciledDate: date('reconciled_date'),
  createdBy: uuid('created_by')
    .notNull()
    .references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Enhanced bills table for tracking financial obligations with advanced scheduling.
 * Supports unique and recurrent payments with custom scheduling options.
 */
export const bills = pgTable('bills', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  buildingId: uuid('building_id')
    .notNull()
    .references(() => buildings.id),
  billNumber: text('bill_number').notNull().unique(),
  title: text('title').notNull(),
  description: text('description'),
  category: billCategoryEnum('category').notNull(),
  vendor: text('vendor'), // Company or service provider
  paymentType: paymentTypeEnum('payment_type').notNull(), // unique or recurrent
  schedulePayment: schedulePaymentEnum('schedule_payment'), // Only for recurrent payments
  scheduleCustom: date('schedule_custom').array(), // Custom dates for custom schedules
  costs: decimal('costs', { precision: 12, scale: 2 }).array().notNull(), // Array of costs for payment plan
  totalAmount: decimal('total_amount', { precision: 12, scale: 2 }).notNull(),
  startDate: date('start_date').notNull(), // When the bill series starts
  endDate: date('end_date'), // For recurrent bills, when they end (optional for ongoing)
  status: billStatusEnum('status').notNull().default('draft'),
  documentPath: text('document_path'), // Path to uploaded bill document
  documentName: text('document_name'), // Original filename
  isAiAnalyzed: boolean('is_ai_analyzed').default(false),
  aiAnalysisData: jsonb('ai_analysis_data'), // Store AI-extracted data
  notes: text('notes'),
  autoGenerated: boolean('auto_generated').notNull().default(false), // Indicates if this bill was auto-generated
  reference: uuid('reference').references(() => bills.id), // References the original bill for auto-generated bills
  createdBy: uuid('created_by')
    .notNull()
    .references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Legacy bills table - keeping for backward compatibility.
 * Will be migrated to new bills table structure.
 */
export const oldBills = pgTable('old_bills', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  residenceId: uuid('residence_id')
    .notNull()
    .references(() => residences.id),
  billNumber: text('bill_number').notNull().unique(),
  type: oldBillTypeEnum('type').notNull(),
  description: text('description').notNull(),
  amount: decimal('amount', { precision: 12, scale: 2 }).notNull(),
  dueDate: date('due_date').notNull(),
  issueDate: date('issue_date').notNull(),
  status: billStatusEnum('status').notNull().default('draft'),
  notes: text('notes'),
  lateFeeAmount: decimal('late_fee_amount', { precision: 10, scale: 2 }),
  discountAmount: decimal('discount_amount', { precision: 10, scale: 2 }),
  finalAmount: decimal('final_amount', { precision: 12, scale: 2 }).notNull(),
  paymentReceivedDate: date('payment_received_date'),
  createdBy: uuid('created_by')
    .notNull()
    .references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Budgets table for tracking financial planning by building and category.
 * Supports operational, reserve, and special project budgets.
 */
export const budgets = pgTable('budgets', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  buildingId: uuid('building_id')
    .notNull()
    .references(() => buildings.id),
  year: integer('year').notNull(),
  name: text('name').notNull(),
  description: text('description'),
  category: text('category').notNull(), // 'operational', 'reserve', 'special_project'
  budgetedAmount: decimal('budgeted_amount', { precision: 12, scale: 2 }).notNull(),
  actualAmount: decimal('actual_amount', { precision: 12, scale: 2 }).default('0'),
  variance: decimal('variance', { precision: 12, scale: 2 }).default('0'),
  approvedBy: uuid('approved_by').references(() => users.id),
  approvedDate: date('approved_date'),
  isActive: boolean('is_active').notNull().default(true),
  createdBy: uuid('created_by')
    .notNull()
    .references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Monthly budgets table for detailed monthly tracking of income and spending by building.
 * Automatically populated for each building from construction date to 25 years in the future.
 * Updated monthly on the 1st and supports approval workflow.
 */
export const monthlyBudgets = pgTable('monthly_budgets', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  buildingId: uuid('building_id')
    .notNull()
    .references(() => buildings.id),
  year: integer('year').notNull(),
  month: integer('month').notNull(), // 1-12
  incomeTypes: text('income_types').array().notNull(), // Array of income categories from money_flow
  incomes: decimal('incomes', { precision: 12, scale: 2 }).array().notNull(), // Array of income amounts corresponding to incomeTypes
  spendingTypes: text('spending_types').array().notNull(), // Array of expense categories from money_flow
  spendings: decimal('spendings', { precision: 12, scale: 2 }).array().notNull(), // Array of spending amounts corresponding to spendingTypes
  approved: boolean('approved').notNull().default(false),
  approvedBy: uuid('approved_by').references(() => users.id),
  approvedDate: timestamp('approved_date'),
  originalBudgetId: uuid('original_budget_id').references(() => monthlyBudgets.id), // References the original budget if this is an approved copy
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Insert schemas
export const insertMoneyFlowSchema = z.object({
  buildingId: z.string().uuid().optional(),
  residenceId: z.string().uuid().optional(),
  billId: z.string().uuid().optional(),
  type: z.string(),
  category: z.string(),
  description: z.string(),
  amount: z.number(),
  transactionDate: z.date(),
  referenceNumber: z.string().optional(),
  notes: z.string().optional(),
  createdBy: z.string().uuid(),
});

export const insertBillSchema = z.object({
  buildingId: z.string().uuid().optional(),
  billNumber: z.string(),
  title: z.string(),
  description: z.string().optional(),
  category: z.string(),
  vendor: z.string().optional(),
  paymentType: z.string(),
  schedulePayment: z.boolean().default(false),
  scheduleCustom: z.string().optional(),
  costs: z.array(z.number()).optional(),
  totalAmount: z.number(),
  startDate: z.date().optional(),
  endDate: z.date().optional(),
  status: z.string().default('draft'),
  documentPath: z.string().optional(),
  documentName: z.string().optional(),
  isAiAnalyzed: z.boolean().default(false),
  aiAnalysisData: z.record(z.string(), z.any()).optional(),
  notes: z.string().optional(),
  createdBy: z.string().uuid(),
});

export const insertOldBillSchema = z.object({
  residenceId: z.string().uuid(),
  billNumber: z.string(),
  type: z.string(),
  description: z.string().optional(),
  amount: z.number(),
  dueDate: z.date(),
  issueDate: z.date().optional(),
  status: z.string().default('unpaid'),
  notes: z.string().optional(),
  lateFeeAmount: z.number().optional(),
  discountAmount: z.number().optional(),
  finalAmount: z.number().optional(),
  paymentReceivedDate: z.date().optional(),
  createdBy: z.string().uuid(),
});

export const insertBudgetSchema = z.object({
  buildingId: z.string().uuid(),
  year: z.number().int(),
  name: z.string(),
  description: z.string().optional(),
  category: z.string(),
  budgetedAmount: z.number(),
  actualAmount: z.number().optional(),
  createdBy: z.string().uuid(),
});

export const insertMonthlyBudgetSchema = z.object({
  buildingId: z.string().uuid(),
  year: z.number().int(),
  month: z.number().int().min(1).max(12),
  incomeTypes: z.array(z.string()),
  incomes: z.array(z.number()),
  spendingTypes: z.array(z.string()),
  spendings: z.array(z.number()),
  approved: z.boolean().default(false),
  approvedBy: z.string().uuid().optional(),
  originalBudgetId: z.string().uuid().optional(),
});

// Types
/**
 * Money flow insert and select types.
 */
export type InsertMoneyFlow = z.infer<typeof insertMoneyFlowSchema>;
/**
 *
 */
export type MoneyFlow = typeof moneyFlow.$inferSelect;

/**
 * Bills insert and select types.
 */
export type InsertBill = z.infer<typeof insertBillSchema>;
/**
 *
 */
export type Bill = typeof bills.$inferSelect;

/**
 * Legacy bills types for backward compatibility.
 */
export type InsertOldBill = z.infer<typeof insertOldBillSchema>;
/**
 *
 */
export type OldBill = typeof oldBills.$inferSelect;

/**
 * Budget insert and select types.
 */
export type InsertBudget = z.infer<typeof insertBudgetSchema>;
/**
 *
 */
export type Budget = typeof budgets.$inferSelect;

/**
 * Monthly budget insert and select types.
 */
export type InsertMonthlyBudget = z.infer<typeof insertMonthlyBudgetSchema>;
/**
 *
 */
export type MonthlyBudget = typeof monthlyBudgets.$inferSelect;

// Relations
export const moneyFlowRelations = relations(moneyFlow, ({ one }) => ({
  building: one(buildings, {
    fields: [moneyFlow.buildingId],
    references: [buildings.id],
  }),
  residence: one(residences, {
    fields: [moneyFlow.residenceId],
    references: [residences.id],
  }),
  bill: one(bills, {
    fields: [moneyFlow.billId],
    references: [bills.id],
  }),
  createdBy: one(users, {
    fields: [moneyFlow.createdBy],
    references: [users.id],
  }),
}));

export const billsRelations = relations(bills, ({ one, many }) => ({
  building: one(buildings, {
    fields: [bills.buildingId],
    references: [buildings.id],
  }),
  createdBy: one(users, {
    fields: [bills.createdBy],
    references: [users.id],
  }),
  originalBill: one(bills, {
    fields: [bills.reference],
    references: [bills.id],
    relationName: 'billReference'
  }),
  generatedBills: many(bills, {
    relationName: 'billReference'
  }),
  moneyFlows: many(moneyFlow),
}));

export const oldBillsRelations = relations(oldBills, ({ one }) => ({
  residence: one(residences, {
    fields: [oldBills.residenceId],
    references: [residences.id],
  }),
  createdBy: one(users, {
    fields: [oldBills.createdBy],
    references: [users.id],
  }),
}));

export const budgetsRelations = relations(budgets, ({ one }) => ({
  building: one(buildings, {
    fields: [budgets.buildingId],
    references: [buildings.id],
  }),
  createdBy: one(users, {
    fields: [budgets.createdBy],
    references: [users.id],
  }),
  approvedBy: one(users, {
    fields: [budgets.approvedBy],
    references: [users.id],
  }),
}));

export const monthlyBudgetsRelations = relations(monthlyBudgets, ({ one }) => ({
  building: one(buildings, {
    fields: [monthlyBudgets.buildingId],
    references: [buildings.id],
  }),
  approvedBy: one(users, {
    fields: [monthlyBudgets.approvedBy],
    references: [users.id],
  }),
  originalBudget: one(monthlyBudgets, {
    fields: [monthlyBudgets.originalBudgetId],
    references: [monthlyBudgets.id],
    relationName: 'budgetCopy'
  }),
}));