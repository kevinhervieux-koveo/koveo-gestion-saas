import { sql } from 'drizzle-orm';
import {
  pgTable,
  text,
  varchar,
  timestamp,
  jsonb,
  uuid,
  pgEnum,
  boolean,
  integer,
  decimal,
  date,
} from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-zod';
import { z } from 'zod';
import { relations } from 'drizzle-orm';

// Enums for improvement suggestions
/**
 * Enum defining categories for improvement suggestions in the development framework.
 * Used to classify suggestions by their focus area.
 */
export const suggestionCategoryEnum = pgEnum('suggestion_category', [
  'Code Quality',
  'Security',
  'Testing',
  'Documentation',
  'Performance',
  'Continuous Improvement',
  'Replit AI Agent Monitoring',
  'Replit App',
]);

// Enums for quality metrics effectiveness tracking
/**
 * Enum defining validation status for metric predictions.
 * Used to track the outcome of metric predictions against real results.
 */
export const validationStatusEnum = pgEnum('validation_status', [
  'pending',
  'true_positive', // Metric correctly predicted an issue
  'false_positive', // Metric predicted issue but none found
  'true_negative', // Metric correctly predicted no issue
  'false_negative', // Metric missed a real issue
]);

/**
 * Enum defining severity levels for quality issues in Quebec property management context.
 * Aligned with Quebec compliance requirements and property management standards.
 */
export const issueSeverityEnum = pgEnum('issue_severity', [
  'info', // Minor suggestions
  'low', // Non-critical improvements
  'medium', // Important but not urgent
  'high', // Significant issues affecting operations
  'critical', // Severe issues affecting compliance or safety
  'quebec_compliance', // Issues affecting Quebec Law 25 or provincial regulations
]);

/**
 * Enum defining metric types for effectiveness tracking.
 * Covers all quality metrics used in property management development.
 */
export const metricTypeEnum = pgEnum('metric_type', [
  'code_coverage',
  'code_quality',
  'security_vulnerabilities',
  'build_time',
  'translation_coverage',
  'api_response_time',
  'memory_usage',
  'bundle_size',
  'database_query_time',
  'page_load_time',
  'accessibility_score',
  'seo_score',
  'quebec_compliance_score',
]);
/**
 * Enum defining priority levels for improvement suggestions.
 * Used to rank suggestions by importance and urgency.
 */
export const suggestionPriorityEnum = pgEnum('suggestion_priority', [
  'Low',
  'Medium',
  'High',
  'Critical',
]);
/**
 * Enum defining status values for improvement suggestions lifecycle.
 * Tracks the progress of suggestions from creation to completion.
 */
export const suggestionStatusEnum = pgEnum('suggestion_status', ['New', 'Acknowledged', 'Done']);

// Enums for features
/**
 * Enum defining status values for feature development lifecycle.
 * Tracks features from request through completion or cancellation.
 */
export const featureStatusEnum = pgEnum('feature_status', [
  'submitted',
  'planned',
  'in-progress',
  'ai-analyzed',
  'completed',
  'cancelled',
]);
/**
 * Enum defining priority levels for feature development.
 * Used to prioritize feature development by importance and business impact.
 */
export const featurePriorityEnum = pgEnum('feature_priority', [
  'low',
  'medium',
  'high',
  'critical',
]);
/**
 * Enum defining functional categories for features in the property management system.
 * Used to organize features by their business domain and functionality.
 */
export const featureCategoryEnum = pgEnum('feature_category', [
  'Dashboard & Home',
  'Property Management',
  'Resident Management',
  'Financial Management',
  'Maintenance & Requests',
  'Document Management',
  'Communication',
  'AI & Automation',
  'Compliance & Security',
  'Analytics & Reporting',
  'Integration & API',
  'Infrastructure & Performance',
  'Website',
]);

// Enums for core application
/**
 * Enum defining user roles in the Quebec property management system.
 * Determines user permissions and access levels across the application.
 */
export const userRoleEnum = pgEnum('user_role', [
  'admin',
  'manager',
  'owner',
  'tenant',
  'board_member',
]);
/**
 * Enum defining status values for feature actionable items.
 * Tracks the lifecycle of actionable items generated by AI analysis.
 */
export const actionableItemStatusEnum = pgEnum('actionable_item_status', [
  'pending',
  'in-progress',
  'completed',
  'blocked',
]);

export const billStatusEnum = pgEnum('bill_status', [
  'draft',
  'sent',
  'overdue',
  'paid',
  'cancelled',
]);
export const billTypeEnum = pgEnum('bill_type', [
  'condo_fees',
  'special_assessment',
  'utility',
  'maintenance',
  'other',
]);
export const maintenanceStatusEnum = pgEnum('maintenance_status', [
  'submitted',
  'acknowledged',
  'in_progress',
  'completed',
  'cancelled',
]);
export const maintenancePriorityEnum = pgEnum('maintenance_priority', [
  'low',
  'medium',
  'high',
  'urgent',
  'emergency',
]);
export const notificationTypeEnum = pgEnum('notification_type', [
  'bill',
  'maintenance',
  'meeting',
  'announcement',
  'document',
  'ssl_certificate',
]);
/**
 * Enum defining building types common in Quebec residential properties.
 * Used to classify properties according to Quebec real estate law.
 */
export const buildingTypeEnum = pgEnum('building_type', [
  'condo',
  'rental',
]);

// Core Application Tables
/**
 * Users table for the Koveo Gestion property management system.
 * Stores user authentication and profile information for all system users.
 * Supports Quebec-specific language preferences and role-based access.
 */
export const users = pgTable('users', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  email: text('email').notNull().unique(),
  password: text('password').notNull(),
  firstName: text('first_name').notNull(),
  lastName: text('last_name').notNull(),
  phone: text('phone'),
  language: text('language').notNull().default('fr'), // Default to French for Quebec
  role: userRoleEnum('role').notNull().default('tenant'),
  isActive: boolean('is_active').notNull().default(true),
  lastLoginAt: timestamp('last_login_at'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Organizations table storing management companies, syndicates, and co-ownership entities.
 * Represents the legal entities responsible for property management in Quebec.
 */
export const organizations = pgTable('organizations', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  name: text('name').notNull(),
  type: text('type').notNull(), // 'management_company', 'syndicate', 'cooperative'
  address: text('address').notNull(),
  city: text('city').notNull(),
  province: text('province').notNull().default('QC'),
  postalCode: text('postal_code').notNull(),
  phone: text('phone'),
  email: text('email'),
  website: text('website'),
  registrationNumber: text('registration_number'), // Quebec business registration
  isActive: boolean('is_active').notNull().default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Buildings table storing individual property information.
 * Each building represents a distinct property managed by an organization.
 */
export const buildings = pgTable('buildings', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  organizationId: uuid('organization_id')
    .notNull()
    .references(() => organizations.id),
  name: text('name').notNull(),
  address: text('address').notNull(),
  city: text('city').notNull(),
  province: text('province').notNull().default('QC'),
  postalCode: text('postal_code').notNull(),
  buildingType: buildingTypeEnum('building_type').notNull(),
  yearBuilt: integer('year_built'),
  totalUnits: integer('total_units').notNull(),
  totalFloors: integer('total_floors'),
  parkingSpaces: integer('parking_spaces'),
  storageSpaces: integer('storage_spaces'),
  amenities: jsonb('amenities'), // Array of amenities
  managementCompany: text('management_company'),
  isActive: boolean('is_active').notNull().default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Residences table storing individual housing units within buildings.
 * Represents apartments, condos, or units that can be occupied by tenants.
 */
export const residences = pgTable('residences', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  buildingId: uuid('building_id')
    .notNull()
    .references(() => buildings.id),
  unitNumber: text('unit_number').notNull(),
  floor: integer('floor'),
  squareFootage: decimal('square_footage', { precision: 8, scale: 2 }),
  bedrooms: integer('bedrooms'),
  bathrooms: decimal('bathrooms', { precision: 3, scale: 1 }),
  balcony: boolean('balcony').default(false),
  parkingSpaceNumber: text('parking_space_number'),
  storageSpaceNumber: text('storage_space_number'),
  ownershipPercentage: decimal('ownership_percentage', { precision: 5, scale: 4 }), // For condos
  monthlyFees: decimal('monthly_fees', { precision: 10, scale: 2 }),
  isActive: boolean('is_active').notNull().default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const userResidences = pgTable('user_residences', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  userId: uuid('user_id')
    .notNull()
    .references(() => users.id),
  residenceId: uuid('residence_id')
    .notNull()
    .references(() => residences.id),
  relationshipType: text('relationship_type').notNull(), // 'owner', 'tenant', 'occupant'
  startDate: date('start_date').notNull(),
  endDate: date('end_date'),
  isActive: boolean('is_active').notNull().default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const bills = pgTable('bills', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  residenceId: uuid('residence_id')
    .notNull()
    .references(() => residences.id),
  billNumber: text('bill_number').notNull().unique(),
  type: billTypeEnum('type').notNull(),
  description: text('description').notNull(),
  amount: decimal('amount', { precision: 12, scale: 2 }).notNull(),
  dueDate: date('due_date').notNull(),
  issueDate: date('issue_date').notNull(),
  status: billStatusEnum('status').notNull().default('draft'),
  notes: text('notes'),
  lateFeeAmount: decimal('late_fee_amount', { precision: 10, scale: 2 }),
  discountAmount: decimal('discount_amount', { precision: 10, scale: 2 }),
  finalAmount: decimal('final_amount', { precision: 12, scale: 2 }).notNull(),
  paymentReceivedDate: date('payment_received_date'),
  createdBy: uuid('created_by')
    .notNull()
    .references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const maintenanceRequests = pgTable('maintenance_requests', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  residenceId: uuid('residence_id')
    .notNull()
    .references(() => residences.id),
  submittedBy: uuid('submitted_by')
    .notNull()
    .references(() => users.id),
  assignedTo: uuid('assigned_to').references(() => users.id),
  title: text('title').notNull(),
  description: text('description').notNull(),
  category: text('category').notNull(), // 'plumbing', 'electrical', 'hvac', 'general', etc.
  priority: maintenancePriorityEnum('priority').notNull().default('medium'),
  status: maintenanceStatusEnum('status').notNull().default('submitted'),
  estimatedCost: decimal('estimated_cost', { precision: 10, scale: 2 }),
  actualCost: decimal('actual_cost', { precision: 10, scale: 2 }),
  scheduledDate: timestamp('scheduled_date'),
  completedDate: timestamp('completed_date'),
  notes: text('notes'),
  images: jsonb('images'), // Array of image URLs
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const budgets = pgTable('budgets', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  buildingId: uuid('building_id')
    .notNull()
    .references(() => buildings.id),
  year: integer('year').notNull(),
  name: text('name').notNull(),
  description: text('description'),
  category: text('category').notNull(), // 'operational', 'reserve', 'special_project'
  budgetedAmount: decimal('budgeted_amount', { precision: 12, scale: 2 }).notNull(),
  actualAmount: decimal('actual_amount', { precision: 12, scale: 2 }).default('0'),
  variance: decimal('variance', { precision: 12, scale: 2 }).default('0'),
  approvedBy: uuid('approved_by').references(() => users.id),
  approvedDate: date('approved_date'),
  isActive: boolean('is_active').notNull().default(true),
  createdBy: uuid('created_by')
    .notNull()
    .references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const documents = pgTable('documents', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  organizationId: uuid('organization_id').references(() => organizations.id),
  buildingId: uuid('building_id').references(() => buildings.id),
  residenceId: uuid('residence_id').references(() => residences.id),
  title: text('title').notNull(),
  description: text('description'),
  category: text('category').notNull(), // 'bylaw', 'financial', 'maintenance', 'legal', 'meeting_minutes'
  fileUrl: text('file_url').notNull(),
  fileName: text('file_name').notNull(),
  fileSize: integer('file_size'),
  mimeType: text('mime_type'),
  isPublic: boolean('is_public').notNull().default(false),
  uploadedBy: uuid('uploaded_by')
    .notNull()
    .references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const notifications = pgTable('notifications', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  userId: uuid('user_id')
    .notNull()
    .references(() => users.id),
  type: notificationTypeEnum('type').notNull(),
  title: text('title').notNull(),
  message: text('message').notNull(),
  relatedEntityId: uuid('related_entity_id'), // ID of related bill, maintenance request, etc.
  relatedEntityType: text('related_entity_type'), // 'bill', 'maintenance_request', etc.
  isRead: boolean('is_read').notNull().default(false),
  readAt: timestamp('read_at'),
  createdAt: timestamp('created_at').defaultNow(),
});

/**
 * Development pillars table for the Pillar Methodology framework.
 * Stores the five core development pillars and their completion status.
 */
export const developmentPillars = pgTable('development_pillars', {
  id: varchar('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  name: text('name').notNull(),
  description: text('description').notNull(),
  status: text('status').notNull().default('pending'), // 'pending', 'in-progress', 'complete'
  order: text('order').notNull(),
  configuration: jsonb('configuration'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const workspaceStatus = pgTable('workspace_status', {
  id: varchar('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  component: text('component').notNull(),
  status: text('status').notNull().default('pending'), // 'pending', 'in-progress', 'complete'
  lastUpdated: timestamp('last_updated').defaultNow(),
});

export const qualityMetrics = pgTable('quality_metrics', {
  id: varchar('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  metricType: text('metric_type').notNull(),
  value: text('value').notNull(),
  timestamp: timestamp('timestamp').defaultNow(),
});

export const frameworkConfiguration = pgTable('framework_configuration', {
  id: varchar('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  key: text('key').notNull().unique(),
  value: jsonb('value').notNull(),
  description: text('description'),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Quality Metrics Effectiveness Tracking Tables

/**
 * Tracks the effectiveness of quality metrics over time.
 * Records accuracy, precision, and calibration data for continuous improvement.
 */
export const metricEffectivenessTracking = pgTable('metric_effectiveness_tracking', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  metricType: metricTypeEnum('metric_type').notNull(),
  calculatedValue: text('calculated_value').notNull(),
  actualOutcome: text('actual_outcome'), // What actually happened
  accuracy: decimal('accuracy', { precision: 5, scale: 2 }), // Percentage accuracy
  precision: decimal('precision', { precision: 5, scale: 2 }), // Precision score
  recall: decimal('recall', { precision: 5, scale: 2 }), // Recall score
  f1Score: decimal('f1_score', { precision: 5, scale: 2 }), // F1 score
  calibrationScore: decimal('calibration_score', { precision: 5, scale: 2 }), // ML calibration score
  predictionConfidence: decimal('prediction_confidence', { precision: 5, scale: 2 }), // Confidence in prediction
  validationDate: timestamp('validation_date'),
  quebecComplianceImpact: boolean('quebec_compliance_impact').default(false),
  propertyManagementContext: jsonb('property_management_context'), // Quebec property management specific context
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Stores predictions made by quality metrics for later validation.
 * Essential for tracking prediction accuracy and improving calibration.
 */
export const metricPredictions = pgTable('metric_predictions', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  metricType: metricTypeEnum('metric_type').notNull(),
  predictedValue: text('predicted_value').notNull(),
  confidenceLevel: decimal('confidence_level', { precision: 5, scale: 2 }).notNull(),
  thresholdUsed: text('threshold_used'), // The threshold that triggered this prediction
  contextData: jsonb('context_data'), // Additional context about the prediction
  predictionReason: text('prediction_reason'), // Why this prediction was made
  expectedSeverity: issueSeverityEnum('expected_severity'),
  quebecComplianceRelevant: boolean('quebec_compliance_relevant').default(false),
  propertyManagementCategory: text('property_management_category'), // e.g., 'tenant_management', 'compliance', 'financial'
  filePath: text('file_path'), // File or component the prediction relates to
  lineNumber: integer('line_number'), // Specific line if applicable
  createdAt: timestamp('created_at').defaultNow(),
});

/**
 * Records validation results when predictions are checked against actual outcomes.
 * Critical for machine learning calibration and accuracy improvement.
 */
export const predictionValidations = pgTable('prediction_validations', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  predictionId: uuid('prediction_id')
    .notNull()
    .references(() => metricPredictions.id, { onDelete: 'cascade' }),
  validationStatus: validationStatusEnum('validation_status').notNull(),
  actualOutcome: text('actual_outcome').notNull(),
  validationMethod: text('validation_method'), // How the validation was performed
  validatorId: varchar('validator_id'), // Who or what performed the validation
  timeTaken: integer('time_taken'), // Minutes from prediction to validation
  impactLevel: issueSeverityEnum('impact_level'), // Actual impact level of the issue
  resolutionActions: jsonb('resolution_actions'), // Actions taken to resolve the issue
  quebecComplianceNotes: text('quebec_compliance_notes'), // Quebec-specific compliance notes
  costImpact: decimal('cost_impact', { precision: 10, scale: 2 }), // Financial impact in CAD
  validatedAt: timestamp('validated_at').defaultNow(),
  createdAt: timestamp('created_at').defaultNow(),
});

/**
 * Stores machine learning calibration data for improving metric accuracy.
 * Enables continuous improvement of prediction models.
 */
export const metricCalibrationData = pgTable('metric_calibration_data', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  metricType: metricTypeEnum('metric_type').notNull(),
  calibrationModel: jsonb('calibration_model').notNull(), // ML model parameters
  trainingDataSize: integer('training_data_size').notNull(),
  accuracy: decimal('accuracy', { precision: 5, scale: 2 }).notNull(),
  precision: decimal('precision', { precision: 5, scale: 2 }).notNull(),
  recall: decimal('recall', { precision: 5, scale: 2 }).notNull(),
  f1Score: decimal('f1_score', { precision: 5, scale: 2 }).notNull(),
  crossValidationScore: decimal('cross_validation_score', { precision: 5, scale: 2 }),
  featureImportance: jsonb('feature_importance'), // Important features for this metric
  hyperparameters: jsonb('hyperparameters'), // ML model hyperparameters
  quebecSpecificFactors: jsonb('quebec_specific_factors'), // Quebec property management specific factors
  lastTrainingDate: timestamp('last_training_date').notNull(),
  modelVersion: text('model_version').notNull(),
  isActive: boolean('is_active').default(true),
  performanceMetrics: jsonb('performance_metrics'), // Additional performance data
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Tracks real quality issues found in the codebase.
 * Used for validating metric predictions and improving accuracy.
 */
export const qualityIssues = pgTable('quality_issues', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  title: text('title').notNull(),
  description: text('description').notNull(),
  category: suggestionCategoryEnum('category').notNull(),
  severity: issueSeverityEnum('severity').notNull(),
  filePath: text('file_path'),
  lineNumber: integer('line_number'),
  detectionMethod: text('detection_method'), // How the issue was found
  detectedBy: text('detected_by'), // Tool, person, or system that found it
  relatedMetricType: metricTypeEnum('related_metric_type'), // Which metric should have caught this
  wasPredicted: boolean('was_predicted').default(false),
  predictionId: uuid('prediction_id')
    .references(() => metricPredictions.id),
  resolutionStatus: text('resolution_status').default('open'), // open, in_progress, resolved, closed
  resolutionTime: integer('resolution_time'), // Hours to resolve
  resolutionActions: jsonb('resolution_actions'),
  quebecComplianceRelated: boolean('quebec_compliance_related').default(false),
  propertyManagementImpact: text('property_management_impact'), // Impact on property management operations
  costToFix: decimal('cost_to_fix', { precision: 10, scale: 2 }), // Estimated cost in CAD
  actualCost: decimal('actual_cost', { precision: 10, scale: 2 }), // Actual resolution cost
  detectedAt: timestamp('detected_at').defaultNow(),
  resolvedAt: timestamp('resolved_at'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Insert schemas for core application
export const insertUserSchema = createInsertSchema(users)
  .pick({
    email: true,
    password: true,
    firstName: true,
    lastName: true,
    phone: true,
    language: true,
    role: true,
  })
  .extend({
    firstName: z.string().min(1).max(100, 'First name must be 100 characters or less'),
    lastName: z.string().min(1).max(100, 'Last name must be 100 characters or less'),
    email: z.string().email('Invalid email address'),
    password: z.string().min(8, 'Password must be at least 8 characters'),
  });

export const insertOrganizationSchema = createInsertSchema(organizations).pick({
  name: true,
  type: true,
  address: true,
  city: true,
  province: true,
  postalCode: true,
  phone: true,
  email: true,
  website: true,
  registrationNumber: true,
});

export const insertBuildingSchema = createInsertSchema(buildings).pick({
  organizationId: true,
  name: true,
  address: true,
  city: true,
  province: true,
  postalCode: true,
  buildingType: true,
  yearBuilt: true,
  totalUnits: true,
  totalFloors: true,
  parkingSpaces: true,
  storageSpaces: true,
  amenities: true,
  managementCompany: true,
});

export const insertResidenceSchema = createInsertSchema(residences).pick({
  buildingId: true,
  unitNumber: true,
  floor: true,
  squareFootage: true,
  bedrooms: true,
  bathrooms: true,
  balcony: true,
  parkingSpaceNumber: true,
  storageSpaceNumber: true,
  ownershipPercentage: true,
  monthlyFees: true,
});

export const insertUserResidenceSchema = createInsertSchema(userResidences).pick({
  userId: true,
  residenceId: true,
  relationshipType: true,
  startDate: true,
  endDate: true,
});

export const insertBillSchema = createInsertSchema(bills).pick({
  residenceId: true,
  billNumber: true,
  type: true,
  description: true,
  amount: true,
  dueDate: true,
  issueDate: true,
  status: true,
  notes: true,
  lateFeeAmount: true,
  discountAmount: true,
  finalAmount: true,
  createdBy: true,
});

export const insertMaintenanceRequestSchema = createInsertSchema(maintenanceRequests).pick({
  residenceId: true,
  submittedBy: true,
  assignedTo: true,
  title: true,
  description: true,
  category: true,
  priority: true,
  estimatedCost: true,
  scheduledDate: true,
  notes: true,
  images: true,
});

export const insertBudgetSchema = createInsertSchema(budgets).pick({
  buildingId: true,
  year: true,
  name: true,
  description: true,
  category: true,
  budgetedAmount: true,
  actualAmount: true,
  createdBy: true,
});

export const insertDocumentSchema = createInsertSchema(documents).pick({
  organizationId: true,
  buildingId: true,
  residenceId: true,
  title: true,
  description: true,
  category: true,
  fileUrl: true,
  fileName: true,
  fileSize: true,
  mimeType: true,
  isPublic: true,
  uploadedBy: true,
});

export const insertNotificationSchema = createInsertSchema(notifications).pick({
  userId: true,
  type: true,
  title: true,
  message: true,
  relatedEntityId: true,
  relatedEntityType: true,
});

export const insertPillarSchema = createInsertSchema(developmentPillars).pick({
  name: true,
  description: true,
  status: true,
  order: true,
  configuration: true,
});

export const insertWorkspaceStatusSchema = createInsertSchema(workspaceStatus).pick({
  component: true,
  status: true,
});

export const insertQualityMetricSchema = createInsertSchema(qualityMetrics).pick({
  metricType: true,
  value: true,
});

export const insertFrameworkConfigSchema = createInsertSchema(frameworkConfiguration).pick({
  key: true,
  value: true,
  description: true,
});

// Insert schemas for quality metrics effectiveness tracking
export const insertMetricEffectivenessTrackingSchema = createInsertSchema(metricEffectivenessTracking).pick({
  metricType: true,
  calculatedValue: true,
  actualOutcome: true,
  accuracy: true,
  precision: true,
  recall: true,
  f1Score: true,
  calibrationScore: true,
  predictionConfidence: true,
  validationDate: true,
  quebecComplianceImpact: true,
  propertyManagementContext: true,
});

export const insertMetricPredictionSchema = createInsertSchema(metricPredictions).pick({
  metricType: true,
  predictedValue: true,
  confidenceLevel: true,
  thresholdUsed: true,
  contextData: true,
  predictionReason: true,
  expectedSeverity: true,
  quebecComplianceRelevant: true,
  propertyManagementCategory: true,
  filePath: true,
  lineNumber: true,
});

export const insertPredictionValidationSchema = createInsertSchema(predictionValidations).pick({
  predictionId: true,
  validationStatus: true,
  actualOutcome: true,
  validationMethod: true,
  validatorId: true,
  timeTaken: true,
  impactLevel: true,
  resolutionActions: true,
  quebecComplianceNotes: true,
  costImpact: true,
  validatedAt: true,
});

export const insertMetricCalibrationDataSchema = createInsertSchema(metricCalibrationData).pick({
  metricType: true,
  calibrationModel: true,
  trainingDataSize: true,
  accuracy: true,
  precision: true,
  recall: true,
  f1Score: true,
  crossValidationScore: true,
  featureImportance: true,
  hyperparameters: true,
  quebecSpecificFactors: true,
  lastTrainingDate: true,
  modelVersion: true,
  isActive: true,
  performanceMetrics: true,
});

export const insertQualityIssueSchema = createInsertSchema(qualityIssues).pick({
  title: true,
  description: true,
  category: true,
  severity: true,
  filePath: true,
  lineNumber: true,
  detectionMethod: true,
  detectedBy: true,
  relatedMetricType: true,
  wasPredicted: true,
  predictionId: true,
  resolutionStatus: true,
  resolutionTime: true,
  resolutionActions: true,
  quebecComplianceRelated: true,
  propertyManagementImpact: true,
  costToFix: true,
  actualCost: true,
  detectedAt: true,
  resolvedAt: true,
});

// Types for core application
/**
 * Type for creating new user records with validation.
 * Derived from the insertUserSchema for type-safe user creation.
 */
export type InsertUser = z.infer<typeof insertUserSchema>;
/**
 * Type representing a complete user record from the database.
 * Inferred from the users table schema for type safety.
 */
export type User = typeof users.$inferSelect;

/**
 * Type for creating new organization records with validation.
 * Derived from the insertOrganizationSchema for type-safe organization creation.
 */
export type InsertOrganization = z.infer<typeof insertOrganizationSchema>;
/**
 * Type representing a complete organization record from the database.
 * Inferred from the organizations table schema for type safety.
 */
export type Organization = typeof organizations.$inferSelect;

/**
 * Type for creating new building records with validation.
 * Derived from the insertBuildingSchema for type-safe building creation.
 */
export type InsertBuilding = z.infer<typeof insertBuildingSchema>;
/**
 * Type representing a complete building record from the database.
 * Inferred from the buildings table schema for type safety.
 */
export type Building = typeof buildings.$inferSelect;

/**
 * Type for creating new residence records with validation.
 * Derived from the insertResidenceSchema for type-safe residence creation.
 */
export type InsertResidence = z.infer<typeof insertResidenceSchema>;
/**
 * Type representing a complete residence record from the database.
 * Inferred from the residences table schema for type safety.
 */
export type Residence = typeof residences.$inferSelect;

/**
 * Type for creating new user-residence relationship records with validation.
 * Derived from the insertUserResidenceSchema for type-safe relationship creation.
 */
export type InsertUserResidence = z.infer<typeof insertUserResidenceSchema>;
/**
 * Type representing a complete user-residence relationship record from the database.
 * Inferred from the userResidences table schema for type safety.
 */
export type UserResidence = typeof userResidences.$inferSelect;

/**
 * Type for creating new bill records with validation.
 * Derived from the insertBillSchema for type-safe bill creation.
 */
export type InsertBill = z.infer<typeof insertBillSchema>;
/**
 * Type representing a complete bill record from the database.
 * Inferred from the bills table schema for type safety.
 */
export type Bill = typeof bills.$inferSelect;

/**
 * Type for creating new maintenance request records with validation.
 * Derived from the insertMaintenanceRequestSchema for type-safe request creation.
 */
export type InsertMaintenanceRequest = z.infer<typeof insertMaintenanceRequestSchema>;
/**
 * Type representing a complete maintenance request record from the database.
 * Inferred from the maintenanceRequests table schema for type safety.
 */
export type MaintenanceRequest = typeof maintenanceRequests.$inferSelect;

/**
 * Type for creating new budget records with validation.
 * Derived from the insertBudgetSchema for type-safe budget creation.
 */
export type InsertBudget = z.infer<typeof insertBudgetSchema>;
/**
 * Type representing a complete budget record from the database.
 * Inferred from the budgets table schema for type safety.
 */
export type Budget = typeof budgets.$inferSelect;

/**
 * Type for creating new document records with validation.
 * Derived from the insertDocumentSchema for type-safe document creation.
 */
export type InsertDocument = z.infer<typeof insertDocumentSchema>;
/**
 * Type representing a complete document record from the database.
 * Inferred from the documents table schema for type safety.
 */
export type Document = typeof documents.$inferSelect;

/**
 * Type for creating new notification records with validation.
 * Derived from the insertNotificationSchema for type-safe notification creation.
 */
export type InsertNotification = z.infer<typeof insertNotificationSchema>;
/**
 * Type representing a complete notification record from the database.
 * Inferred from the notifications table schema for type safety.
 */
export type Notification = typeof notifications.$inferSelect;

// Framework types
/**
 * Type for creating new development pillar records with validation.
 * Derived from the insertPillarSchema for type-safe pillar creation.
 */
export type InsertPillar = z.infer<typeof insertPillarSchema>;
/**
 * Type representing a complete development pillar record from the database.
 * Inferred from the developmentPillars table schema for type safety.
 */
export type DevelopmentPillar = typeof developmentPillars.$inferSelect;

/**
 * Type for creating new workspace status records with validation.
 * Derived from the insertWorkspaceStatusSchema for type-safe status creation.
 */
export type InsertWorkspaceStatus = z.infer<typeof insertWorkspaceStatusSchema>;
/**
 * Type representing a complete workspace status record from the database.
 * Inferred from the workspaceStatus table schema for type safety.
 */
export type WorkspaceStatus = typeof workspaceStatus.$inferSelect;

/**
 * Type for creating new quality metric records with validation.
 * Derived from the insertQualityMetricSchema for type-safe metric creation.
 */
export type InsertQualityMetric = z.infer<typeof insertQualityMetricSchema>;
/**
 * Type representing a complete quality metric record from the database.
 * Inferred from the qualityMetrics table schema for type safety.
 */
export type QualityMetric = typeof qualityMetrics.$inferSelect;

/**
 * Type for creating new framework configuration records with validation.
 * Derived from the insertFrameworkConfigSchema for type-safe config creation.
 */
export type InsertFrameworkConfig = z.infer<typeof insertFrameworkConfigSchema>;
/**
 * Type representing a complete framework configuration record from the database.
 * Inferred from the frameworkConfiguration table schema for type safety.
 */
export type FrameworkConfiguration = typeof frameworkConfiguration.$inferSelect;

// Types for quality metrics effectiveness tracking
/**
 * Type for creating new metric effectiveness tracking records.
 * Used to record the performance and accuracy of quality metrics over time.
 */
export type InsertMetricEffectivenessTracking = z.infer<typeof insertMetricEffectivenessTrackingSchema>;
/**
 * Type representing a complete metric effectiveness tracking record from the database.
 * Contains all data about metric performance, accuracy, and calibration.
 */
export type MetricEffectivenessTracking = typeof metricEffectivenessTracking.$inferSelect;

/**
 * Type for creating new metric prediction records.
 * Used to store predictions made by quality metrics for later validation.
 */
export type InsertMetricPrediction = z.infer<typeof insertMetricPredictionSchema>;
/**
 * Type representing a complete metric prediction record from the database.
 * Contains prediction data and confidence levels for quality metrics.
 */
export type MetricPrediction = typeof metricPredictions.$inferSelect;

/**
 * Type for creating new prediction validation records.
 * Used to record the outcome when predictions are validated against reality.
 */
export type InsertPredictionValidation = z.infer<typeof insertPredictionValidationSchema>;
/**
 * Type representing a complete prediction validation record from the database.
 * Contains validation results and accuracy measurements.
 */
export type PredictionValidation = typeof predictionValidations.$inferSelect;

/**
 * Type for creating new metric calibration data records.
 * Used to store machine learning calibration information for quality metrics.
 */
export type InsertMetricCalibrationData = z.infer<typeof insertMetricCalibrationDataSchema>;
/**
 * Type representing a complete metric calibration data record from the database.
 * Contains ML model parameters and performance metrics.
 */
export type MetricCalibrationData = typeof metricCalibrationData.$inferSelect;

/**
 * Type for creating new quality issue records.
 * Used to track real quality issues found in the codebase for metric validation.
 */
export type InsertQualityIssue = z.infer<typeof insertQualityIssueSchema>;
/**
 * Type representing a complete quality issue record from the database.
 * Contains comprehensive information about detected quality issues and their resolution.
 */
export type QualityIssue = typeof qualityIssues.$inferSelect;

// Improvement Suggestions table
export const improvementSuggestions = pgTable('improvement_suggestions', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  title: text('title').notNull(),
  description: text('description').notNull(),
  category: suggestionCategoryEnum('category').notNull(),
  priority: suggestionPriorityEnum('priority').notNull(),
  status: suggestionStatusEnum('status').notNull().default('New'),
  filePath: text('file_path'),
  createdAt: timestamp('created_at').defaultNow(),
});

// Insert schema for improvement suggestions
export const insertImprovementSuggestionSchema = createInsertSchema(improvementSuggestions).pick({
  title: true,
  description: true,
  category: true,
  priority: true,
  status: true,
  filePath: true,
});

// Types for improvement suggestions
/**
 *
 */
export type InsertImprovementSuggestion = z.infer<typeof insertImprovementSuggestionSchema>;
/**
 *
 */
export type ImprovementSuggestion = typeof improvementSuggestions.$inferSelect;

// Features table
/**
 * Features table for tracking development roadmap items and functionality.
 * Used by the Pillar Methodology framework for feature planning and tracking.
 */
export const features = pgTable('features', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  name: text('name').notNull(),
  description: text('description').notNull(),
  category: featureCategoryEnum('category').notNull(),
  status: featureStatusEnum('status').notNull().default('submitted'),
  priority: featurePriorityEnum('priority').notNull().default('medium'),
  // User planning fields
  businessObjective: text('business_objective'),
  targetUsers: text('target_users'),
  successMetrics: text('success_metrics'),
  technicalComplexity: text('technical_complexity'),
  dependencies: text('dependencies'),
  userFlow: text('user_flow'),
  // AI analysis fields  
  aiAnalysisResult: jsonb('ai_analysis_result'), // Stores Gemini analysis
  aiAnalyzedAt: timestamp('ai_analyzed_at'),
  // Legacy fields
  requestedBy: uuid('requested_by').references(() => users.id),
  assignedTo: uuid('assigned_to').references(() => users.id),
  estimatedHours: integer('estimated_hours'),
  actualHours: integer('actual_hours'),
  startDate: date('start_date'),
  completedDate: date('completed_date'),
  isPublicRoadmap: boolean('is_public_roadmap').notNull().default(true),
  isStrategicPath: boolean('is_strategic_path').notNull().default(false),
  tags: jsonb('tags'),
  metadata: jsonb('metadata'),
  syncedAt: timestamp('synced_at'), // Tracks when feature was last synced between environments
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Actionable items table storing AI-generated action items for features.
 * Each item represents a specific task to complete a feature.
 */
export const actionableItems = pgTable('actionable_items', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  featureId: uuid('feature_id')
    .notNull()
    .references(() => features.id, { onDelete: 'cascade' }),
  title: text('title').notNull(),
  description: text('description').notNull(),
  technicalDetails: text('technical_details'),
  implementationPrompt: text('implementation_prompt'), // Prompt for Replit AI agent
  testingRequirements: text('testing_requirements'),
  estimatedEffort: text('estimated_effort'), // e.g., "2 hours", "1 day"
  dependencies: jsonb('dependencies'), // Array of other actionable item IDs
  status: actionableItemStatusEnum('status').notNull().default('pending'),
  completedAt: timestamp('completed_at'),
  orderIndex: integer('order_index').notNull().default(0),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Insert schema for features
export const insertFeatureSchema = createInsertSchema(features).pick({
  name: true,
  description: true,
  category: true,
  status: true,
  priority: true,
  businessObjective: true,
  targetUsers: true,
  successMetrics: true,
  technicalComplexity: true,
  dependencies: true,
  userFlow: true,
  requestedBy: true,
  assignedTo: true,
  estimatedHours: true,
  startDate: true,
  completedDate: true,
  isPublicRoadmap: true,
  tags: true,
  metadata: true,
});

// Insert schema for actionable items
export const insertActionableItemSchema = createInsertSchema(actionableItems).pick({
  featureId: true,
  title: true,
  description: true,
  technicalDetails: true,
  implementationPrompt: true,
  testingRequirements: true,
  estimatedEffort: true,
  dependencies: true,
  status: true,
  orderIndex: true,
});

// Types for features
/**
 *
 */
export type InsertFeature = z.infer<typeof insertFeatureSchema>;
/**
 *
 */
export type Feature = typeof features.$inferSelect;

/**
 * Type for creating new actionable item records with validation.
 */
export type InsertActionableItem = z.infer<typeof insertActionableItemSchema>;
/**
 * Type representing a complete actionable item record from the database.
 */
export type ActionableItem = typeof actionableItems.$inferSelect;

// AI Monitoring Tables

/**
 * Enum defining AI interaction statuses.
 * Tracks the success state of AI agent operations.
 */
export const aiInteractionStatusEnum = pgEnum('ai_interaction_status', [
  'success',
  'error',
  'pending',
]);

/**
 * Enum defining AI insight types.
 * Categories for AI-generated improvement recommendations.
 */
export const aiInsightTypeEnum = pgEnum('ai_insight_type', [
  'performance',
  'quality',
  'security',
  'ux',
  'efficiency',
]);

/**
 * Enum defining AI insight priorities.
 * Importance levels for AI-generated recommendations.
 */
export const aiInsightPriorityEnum = pgEnum('ai_insight_priority', [
  'low',
  'medium',
  'high',
]);

/**
 * Enum defining AI insight statuses.
 * Tracks the lifecycle of AI recommendations.
 */
export const aiInsightStatusEnum = pgEnum('ai_insight_status', [
  'new',
  'in_progress',
  'completed',
]);

/**
 * Table for tracking AI agent interactions.
 * Records all interactions between the Replit AI agent and the application.
 */
export const aiInteractions = pgTable('ai_interactions', {
  id: uuid('id').defaultRandom().primaryKey(),
  timestamp: timestamp('timestamp').defaultNow().notNull(),
  action: text('action').notNull(),
  category: varchar('category', { length: 100 }).notNull(),
  duration: integer('duration').notNull(), // in milliseconds
  status: aiInteractionStatusEnum('status').notNull(),
  improvement: text('improvement'),
  impact: varchar('impact', { length: 20 }), // 'high', 'medium', 'low'
  metadata: jsonb('metadata'),
  createdAt: timestamp('created_at').defaultNow(),
});

/**
 * Table for storing AI-generated insights.
 * Contains improvement recommendations from AI analysis.
 */
export const aiInsights = pgTable('ai_insights', {
  id: uuid('id').defaultRandom().primaryKey(),
  type: aiInsightTypeEnum('type').notNull(),
  title: varchar('title', { length: 255 }).notNull(),
  description: text('description').notNull(),
  recommendation: text('recommendation').notNull(),
  priority: aiInsightPriorityEnum('priority').notNull(),
  status: aiInsightStatusEnum('status').notNull().default('new'),
  implementedAt: timestamp('implemented_at'),
  implementedBy: uuid('implemented_by').references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Table for AI metrics aggregation.
 * Stores calculated metrics for AI performance monitoring.
 */
export const aiMetrics = pgTable('ai_metrics', {
  id: uuid('id').defaultRandom().primaryKey(),
  date: date('date').notNull(),
  totalInteractions: integer('total_interactions').default(0),
  successRate: decimal('success_rate', { precision: 5, scale: 2 }).default('0'),
  avgResponseTime: integer('avg_response_time').default(0), // in milliseconds
  improvementsSuggested: integer('improvements_suggested').default(0),
  improvementsImplemented: integer('improvements_implemented').default(0),
  categoriesAnalyzed: jsonb('categories_analyzed').default('[]'),
  lastAnalysis: timestamp('last_analysis').defaultNow(),
  aiEfficiency: decimal('ai_efficiency', { precision: 5, scale: 2 }).default('0'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Export types for AI monitoring
/**
 *
 */
export type AIInteraction = typeof aiInteractions.$inferSelect;
/**
 *
 */
export type InsertAIInteraction = typeof aiInteractions.$inferInsert;
/**
 *
 */
export type AIInsight = typeof aiInsights.$inferSelect;
/**
 *
 */
export type InsertAIInsight = typeof aiInsights.$inferInsert;
/**
 *
 */
export type AIMetrics = typeof aiMetrics.$inferSelect;
/**
 *
 */
export type InsertAIMetrics = typeof aiMetrics.$inferInsert;

// Relations
export const organizationsRelations = relations(organizations, ({ many }) => ({
  buildings: many(buildings),
  documents: many(documents),
}));

export const buildingsRelations = relations(buildings, ({ one, many }) => ({
  organization: one(organizations, {
    fields: [buildings.organizationId],
    references: [organizations.id],
  }),
  residences: many(residences),
  budgets: many(budgets),
  documents: many(documents),
}));

export const residencesRelations = relations(residences, ({ one, many }) => ({
  building: one(buildings, {
    fields: [residences.buildingId],
    references: [buildings.id],
  }),
  userResidences: many(userResidences),
  bills: many(bills),
  maintenanceRequests: many(maintenanceRequests),
  documents: many(documents),
}));

export const usersRelations = relations(users, ({ many }) => ({
  userResidences: many(userResidences),
  createdBills: many(bills),
  submittedMaintenanceRequests: many(maintenanceRequests),
  assignedMaintenanceRequests: many(maintenanceRequests),
  createdBudgets: many(budgets),
  uploadedDocuments: many(documents),
  notifications: many(notifications),
}));

export const userResidencesRelations = relations(userResidences, ({ one }) => ({
  user: one(users, {
    fields: [userResidences.userId],
    references: [users.id],
  }),
  residence: one(residences, {
    fields: [userResidences.residenceId],
    references: [residences.id],
  }),
}));

export const billsRelations = relations(bills, ({ one }) => ({
  residence: one(residences, {
    fields: [bills.residenceId],
    references: [residences.id],
  }),
  createdBy: one(users, {
    fields: [bills.createdBy],
    references: [users.id],
  }),
}));

export const maintenanceRequestsRelations = relations(maintenanceRequests, ({ one }) => ({
  residence: one(residences, {
    fields: [maintenanceRequests.residenceId],
    references: [residences.id],
  }),
  submittedBy: one(users, {
    fields: [maintenanceRequests.submittedBy],
    references: [users.id],
  }),
  assignedTo: one(users, {
    fields: [maintenanceRequests.assignedTo],
    references: [users.id],
  }),
}));

export const budgetsRelations = relations(budgets, ({ one }) => ({
  building: one(buildings, {
    fields: [budgets.buildingId],
    references: [buildings.id],
  }),
  createdBy: one(users, {
    fields: [budgets.createdBy],
    references: [users.id],
  }),
  approvedBy: one(users, {
    fields: [budgets.approvedBy],
    references: [users.id],
  }),
}));

export const documentsRelations = relations(documents, ({ one }) => ({
  organization: one(organizations, {
    fields: [documents.organizationId],
    references: [organizations.id],
  }),
  building: one(buildings, {
    fields: [documents.buildingId],
    references: [buildings.id],
  }),
  residence: one(residences, {
    fields: [documents.residenceId],
    references: [residences.id],
  }),
  uploadedBy: one(users, {
    fields: [documents.uploadedBy],
    references: [users.id],
  }),
}));

export const notificationsRelations = relations(notifications, ({ one }) => ({
  user: one(users, {
    fields: [notifications.userId],
    references: [users.id],
  }),
}));

export const featuresRelations = relations(features, ({ one, many }) => ({
  actionableItems: many(actionableItems),
  requestedByUser: one(users, {
    fields: [features.requestedBy],
    references: [users.id],
  }),
  assignedToUser: one(users, {
    fields: [features.assignedTo],
    references: [users.id],
  }),
}));

export const actionableItemsRelations = relations(actionableItems, ({ one }) => ({
  feature: one(features, {
    fields: [actionableItems.featureId],
    references: [features.id],
  }),
}));

export const aiInsightsRelations = relations(aiInsights, ({ one }) => ({
  implementedByUser: one(users, {
    fields: [aiInsights.implementedBy],
    references: [users.id],
  }),
}));

// RBAC Permission System

/**
 * Enum defining resource types for RBAC permissions.
 * Used to specify what type of resource a permission applies to.
 */
export const resourceTypeEnum = pgEnum('resource_type', [
  'organizations',
  'buildings', 
  'residences',
  'users',
  'bills',
  'maintenance_requests',
  'budgets',
  'documents',
  'notifications',
  'features',
  'quality_metrics',
  'reports',
]);

/**
 * Enum defining action types for RBAC permissions.
 * Used to specify what actions can be performed on resources.
 */
export const actionTypeEnum = pgEnum('action_type', [
  'create',
  'read',
  'update',
  'delete',
  'approve',
  'assign',
  'manage_permissions',
  'generate_reports',
  'export_data',
  'manage_users',
]);

/**
 * Permissions table storing system-wide permissions.
 * Defines granular permissions that can be assigned to roles or users.
 */
export const permissions = pgTable('permissions', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  name: text('name').notNull().unique(),
  displayName: text('display_name').notNull(),
  description: text('description'),
  resourceType: resourceTypeEnum('resource_type').notNull(),
  action: actionTypeEnum('action').notNull(),
  conditions: jsonb('conditions'), // Optional conditions for conditional permissions
  isActive: boolean('is_active').notNull().default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

/**
 * Role permissions table linking roles to their permissions.
 * Defines which permissions are granted to each role.
 */
export const rolePermissions = pgTable('role_permissions', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  role: userRoleEnum('role').notNull(),
  permissionId: uuid('permission_id')
    .notNull()
    .references(() => permissions.id, { onDelete: 'cascade' }),
  grantedBy: uuid('granted_by')
    .notNull()
    .references(() => users.id),
  grantedAt: timestamp('granted_at').defaultNow(),
  createdAt: timestamp('created_at').defaultNow(),
});

/**
 * User permissions table for granting specific permissions to individual users.
 * Allows for user-specific permission overrides beyond their role.
 */
export const userPermissions = pgTable('user_permissions', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  userId: uuid('user_id')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  permissionId: uuid('permission_id')
    .notNull()
    .references(() => permissions.id, { onDelete: 'cascade' }),
  granted: boolean('granted').notNull().default(true), // true = grant, false = revoke
  grantedBy: uuid('granted_by')
    .notNull()
    .references(() => users.id),
  reason: text('reason'), // Optional reason for granting/revoking
  grantedAt: timestamp('granted_at').defaultNow(),
  createdAt: timestamp('created_at').defaultNow(),
});

// RBAC Relations
export const permissionsRelations = relations(permissions, ({ many }) => ({
  rolePermissions: many(rolePermissions),
  userPermissions: many(userPermissions),
}));

export const rolePermissionsRelations = relations(rolePermissions, ({ one }) => ({
  permission: one(permissions, {
    fields: [rolePermissions.permissionId],
    references: [permissions.id],
  }),
  grantedBy: one(users, {
    fields: [rolePermissions.grantedBy],
    references: [users.id],
  }),
}));

export const userPermissionsRelations = relations(userPermissions, ({ one }) => ({
  user: one(users, {
    fields: [userPermissions.userId],
    references: [users.id],
  }),
  permission: one(permissions, {
    fields: [userPermissions.permissionId],
    references: [permissions.id],
  }),
  grantedBy: one(users, {
    fields: [userPermissions.grantedBy],
    references: [users.id],
  }),
}));

// RBAC Insert and Select Schemas
export const insertPermissionSchema = createInsertSchema(permissions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});
export type InsertPermission = z.infer<typeof insertPermissionSchema>;
export type Permission = typeof permissions.$inferSelect;

export const insertRolePermissionSchema = createInsertSchema(rolePermissions).omit({
  id: true,
  grantedAt: true,
  createdAt: true,
});
export type InsertRolePermission = z.infer<typeof insertRolePermissionSchema>;
export type RolePermission = typeof rolePermissions.$inferSelect;

export const insertUserPermissionSchema = createInsertSchema(userPermissions).omit({
  id: true,
  grantedAt: true,
  createdAt: true,
});
export type InsertUserPermission = z.infer<typeof insertUserPermissionSchema>;
export type UserPermission = typeof userPermissions.$inferSelect;

// SSL Certificates Management

/**
 * Enum defining SSL certificate status values.
 * Tracks the lifecycle and health of SSL certificates.
 */
export const certificateStatusEnum = pgEnum('certificate_status', [
  'active',
  'expiring',
  'expired',
  'revoked',
  'pending_renewal',
  'renewal_failed',
]);

/**
 * SSL certificates table for managing domain SSL certificates.
 * Stores certificate metadata, expiry tracking, and renewal status.
 */
export const sslCertificates = pgTable('ssl_certificates', {
  id: uuid('id')
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  domain: text('domain').notNull().unique(),
  certificateData: text('certificate_data').notNull(), // PEM format certificate
  privateKey: text('private_key').notNull(), // Encrypted private key
  certificateChain: text('certificate_chain'), // Full certificate chain
  issuer: text('issuer').notNull(),
  subject: text('subject').notNull(),
  serialNumber: text('serial_number').notNull(),
  fingerprint: text('fingerprint').notNull(),
  validFrom: timestamp('valid_from').notNull(),
  validTo: timestamp('valid_to').notNull(),
  status: certificateStatusEnum('status').notNull().default('active'),
  autoRenew: boolean('auto_renew').notNull().default(true),
  lastRenewalAttempt: timestamp('last_renewal_attempt'),
  renewalAttempts: integer('renewal_attempts').notNull().default(0),
  maxRenewalAttempts: integer('max_renewal_attempts').notNull().default(3),
  renewalError: text('renewal_error'), // Last renewal error message
  dnsProvider: text('dns_provider'), // DNS provider for automated challenges
  dnsCredentials: jsonb('dns_credentials'), // Encrypted DNS API credentials
  notificationEmails: jsonb('notification_emails'), // Array of emails for notifications
  createdBy: varchar('created_by').references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// SSL Certificates Relations
export const sslCertificatesRelations = relations(sslCertificates, ({ one }) => ({
  createdBy: one(users, {
    fields: [sslCertificates.createdBy],
    references: [users.id],
  }),
}));

// SSL Certificates Insert and Select Schemas
export const insertSSLCertificateSchema = createInsertSchema(sslCertificates).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});
export type InsertSSLCertificate = z.infer<typeof insertSSLCertificateSchema>;
export type SSLCertificate = typeof sslCertificates.$inferSelect;
