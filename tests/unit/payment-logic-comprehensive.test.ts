import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { billGenerationService } from '../../server/services/bill-generation-service';
import { db } from '../../server/db';
import { bills } from '../../shared/schemas/financial';
import { eq, and } from 'drizzle-orm';

/**
 * Comprehensive test suite for Complex Payment Logic
 * Tests all sophisticated payment scenarios including:
 * - Split payments (60% now, 40% later)
 * - Multiple installment plans
 * - Annual bills with monthly payments
 * - Quarterly with varying amounts
 * - Custom payment schedules
 * - Edge cases and calculations
 */

describe('Complex Payment Logic Comprehensive Tests', () => {
  const mockBuilding = { id: 'building-payment-test', organizationId: 'org-123' };
  const mockUser = { id: 'user-payment-test' };

  beforeEach(async () => {
    // Clean up test data
    await db.delete(bills).where(eq(bills.buildingId, mockBuilding.id));
  });

  afterEach(async () => {
    await db.delete(bills).where(eq(bills.buildingId, mockBuilding.id));
  });

  describe('Split Payment Scenarios', () => {
    it('should handle 60% now, 40% in 2 months split payment', async () => {
      const parentBill = {
        id: 'split-60-40',
        buildingId: mockBuilding.id,
        billNumber: 'SPLIT-60-40-001',
        title: 'Annual Insurance Premium - Split Payment',
        description: '60% immediate, 40% deferred',
        category: 'insurance',
        vendor: 'Insurance Corp',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        scheduleCustom: null,
        costs: ['6000.00', '4000.00'], // 60% and 40%
        totalAmount: '10000.00',
        startDate: '2024-01-01',
        endDate: '2026-01-01', // 2 years
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockUser.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Should generate 4 bills (2 years * 2 payments per year)
      expect(result.billsCreated).toBe(4);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify payment amounts
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(6000); // 60% first payment
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(4000); // 40% second payment
      expect(parseFloat(generatedBills[2].totalAmount)).toBe(6000); // 60% next year
      expect(parseFloat(generatedBills[3].totalAmount)).toBe(4000); // 40% next year

      // Verify payment timing (1 month apart)
      const firstDate = new Date(generatedBills[0].startDate);
      const secondDate = new Date(generatedBills[1].startDate);
      const monthsDiff = (secondDate.getFullYear() - firstDate.getFullYear()) * 12 + 
                        (secondDate.getMonth() - firstDate.getMonth());
      expect(monthsDiff).toBe(1);

      // Verify titles show split information
      expect(generatedBills[0].title).toContain('Part 1/2');
      expect(generatedBills[1].title).toContain('Part 2/2');
    });

    it('should handle 30% / 30% / 40% three-way split payment', async () => {
      const parentBill = {
        id: 'split-30-30-40',
        buildingId: mockBuilding.id,
        billNumber: 'SPLIT-30-30-40-001',
        title: 'Major Renovation - Three-Phase Payment',
        category: 'maintenance',
        vendor: 'Renovation Corp',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        costs: ['15000.00', '15000.00', '20000.00'], // 30%, 30%, 40%
        totalAmount: '50000.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01', // 1 year
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Should generate 3 bills (1 year * 3 payments)
      expect(result.billsCreated).toBe(3);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify payment amounts
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(15000); // 30%
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(15000); // 30%
      expect(parseFloat(generatedBills[2].totalAmount)).toBe(20000); // 40%

      // Verify titles show correct part numbers
      expect(generatedBills[0].title).toContain('Part 1/3');
      expect(generatedBills[1].title).toContain('Part 2/3');
      expect(generatedBills[2].title).toContain('Part 3/3');
    });

    it('should handle unequal split payments with custom timing', async () => {
      const parentBill = {
        id: 'split-unequal',
        buildingId: mockBuilding.id,
        billNumber: 'SPLIT-UNEQUAL-001',
        title: 'Equipment Purchase - Phased Payment',
        category: 'supplies',
        vendor: 'Equipment Supplier',
        paymentType: 'recurrent',
        schedulePayment: 'custom',
        scheduleCustom: ['2024-01-15', '2024-04-15', '2024-07-15', '2024-10-15'], // Quarterly
        costs: ['25000.00', '15000.00', '10000.00', '5000.00'], // Decreasing amounts
        totalAmount: '55000.00',
        startDate: '2024-01-01',
        endDate: '2024-12-31',
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(4);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify decreasing payment amounts
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(25000); // Largest first
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(15000);
      expect(parseFloat(generatedBills[2].totalAmount)).toBe(10000);
      expect(parseFloat(generatedBills[3].totalAmount)).toBe(5000); // Smallest last

      // Verify custom dates are respected
      expect(generatedBills[0].startDate).toBe('2024-01-15');
      expect(generatedBills[1].startDate).toBe('2024-04-15');
      expect(generatedBills[2].startDate).toBe('2024-07-15');
      expect(generatedBills[3].startDate).toBe('2024-10-15');
    });
  });

  describe('Annual Bills with Monthly Installments', () => {
    it('should handle annual insurance paid monthly', async () => {
      const parentBill = {
        id: 'annual-monthly',
        buildingId: mockBuilding.id,
        billNumber: 'ANNUAL-MONTHLY-001',
        title: 'Annual Insurance - Monthly Payments',
        category: 'insurance',
        vendor: 'Insurance Provider',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        costs: Array(12).fill('500.00'), // 12 monthly payments of $500
        totalAmount: '6000.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01',
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(12); // 12 monthly payments

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify all payments are $500
      generatedBills.forEach(bill => {
        expect(parseFloat(bill.totalAmount)).toBe(500);
      });

      // Verify monthly progression
      for (let i = 1; i < generatedBills.length; i++) {
        const prevDate = new Date(generatedBills[i-1].startDate);
        const currDate = new Date(generatedBills[i].startDate);
        const monthsDiff = (currDate.getFullYear() - prevDate.getFullYear()) * 12 + 
                          (currDate.getMonth() - prevDate.getMonth());
        expect(monthsDiff).toBe(1);
      }

      // Verify part numbering
      expect(generatedBills[0].title).toContain('Part 1/12');
      expect(generatedBills[11].title).toContain('Part 12/12');
    });

    it('should handle annual bill with varying monthly amounts', async () => {
      const monthlyCosts = [
        '800.00', '800.00', '800.00', // Q1 - higher winter costs
        '600.00', '600.00', '600.00', // Q2 - moderate spring costs
        '400.00', '400.00', '400.00', // Q3 - lower summer costs
        '700.00', '700.00', '700.00'  // Q4 - higher fall costs
      ];

      const parentBill = {
        id: 'annual-variable-monthly',
        buildingId: mockBuilding.id,
        billNumber: 'ANNUAL-VAR-MONTHLY-001',
        title: 'Annual Utilities - Seasonal Monthly Payments',
        category: 'utilities',
        vendor: 'Utility Company',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        costs: monthlyCosts,
        totalAmount: '7800.00', // Sum of all monthly costs
        startDate: '2024-01-01',
        endDate: '2025-01-01',
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(12);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify seasonal amounts
      // Q1 (Jan-Mar) - $800
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(800);
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(800);
      expect(parseFloat(generatedBills[2].totalAmount)).toBe(800);

      // Q2 (Apr-Jun) - $600
      expect(parseFloat(generatedBills[3].totalAmount)).toBe(600);
      expect(parseFloat(generatedBills[4].totalAmount)).toBe(600);
      expect(parseFloat(generatedBills[5].totalAmount)).toBe(600);

      // Q3 (Jul-Sep) - $400
      expect(parseFloat(generatedBills[6].totalAmount)).toBe(400);
      expect(parseFloat(generatedBills[7].totalAmount)).toBe(400);
      expect(parseFloat(generatedBills[8].totalAmount)).toBe(400);

      // Q4 (Oct-Dec) - $700
      expect(parseFloat(generatedBills[9].totalAmount)).toBe(700);
      expect(parseFloat(generatedBills[10].totalAmount)).toBe(700);
      expect(parseFloat(generatedBills[11].totalAmount)).toBe(700);
    });
  });

  describe('Quarterly Payment Variations', () => {
    it('should handle quarterly bills with increasing amounts', async () => {
      const parentBill = {
        id: 'quarterly-increasing',
        buildingId: mockBuilding.id,
        billNumber: 'QUARTERLY-INC-001',
        title: 'Quarterly Maintenance - Escalating Costs',
        category: 'maintenance',
        vendor: 'Maintenance Services',
        paymentType: 'recurrent',
        schedulePayment: 'quarterly',
        costs: ['2000.00', '2200.00', '2400.00', '2600.00'], // 10% increases
        totalAmount: '9200.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01',
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(4);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify escalating amounts
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(2000);
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(2200);
      expect(parseFloat(generatedBills[2].totalAmount)).toBe(2400);
      expect(parseFloat(generatedBills[3].totalAmount)).toBe(2600);

      // Verify quarterly timing (3 month intervals)
      for (let i = 1; i < generatedBills.length; i++) {
        const prevDate = new Date(generatedBills[i-1].startDate);
        const currDate = new Date(generatedBills[i].startDate);
        const monthsDiff = (currDate.getFullYear() - prevDate.getFullYear()) * 12 + 
                          (currDate.getMonth() - prevDate.getMonth());
        expect(monthsDiff).toBe(3);
      }
    });

    it('should handle quarterly bills with custom dates and amounts', async () => {
      const parentBill = {
        id: 'quarterly-custom',
        buildingId: mockBuilding.id,
        billNumber: 'QUARTERLY-CUSTOM-001',
        title: 'Quarterly Services - Custom Schedule',
        category: 'professional_services',
        vendor: 'Professional Services Corp',
        paymentType: 'recurrent',
        schedulePayment: 'custom',
        scheduleCustom: ['2024-01-31', '2024-04-30', '2024-07-31', '2024-10-31'], // End of quarters
        costs: ['3000.00', '3500.00', '2800.00', '4200.00'], // Varying amounts
        totalAmount: '13500.00',
        startDate: '2024-01-01',
        endDate: '2024-12-31',
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(4);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify custom dates
      expect(generatedBills[0].startDate).toBe('2024-01-31');
      expect(generatedBills[1].startDate).toBe('2024-04-30');
      expect(generatedBills[2].startDate).toBe('2024-07-31');
      expect(generatedBills[3].startDate).toBe('2024-10-31');

      // Verify varying amounts
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(3000);
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(3500);
      expect(parseFloat(generatedBills[2].totalAmount)).toBe(2800);
      expect(parseFloat(generatedBills[3].totalAmount)).toBe(4200);
    });
  });

  describe('Complex Multi-Year Payment Plans', () => {
    it('should handle 5-year project with annual milestone payments', async () => {
      const parentBill = {
        id: 'multi-year-project',
        buildingId: mockBuilding.id,
        billNumber: 'PROJECT-5YEAR-001',
        title: 'Building Renovation - 5-Year Project',
        category: 'maintenance',
        vendor: 'Major Construction Corp',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        costs: ['100000.00', '120000.00', '80000.00', '60000.00', '40000.00'], // Decreasing over time
        totalAmount: '400000.00',
        startDate: '2024-01-01',
        endDate: '2029-01-01',
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(25); // 5 years * 5 payments per year

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify payment pattern repeats each year
      const expectedAmounts = [100000, 120000, 80000, 60000, 40000];
      
      for (let year = 0; year < 5; year++) {
        for (let payment = 0; payment < 5; payment++) {
          const billIndex = year * 5 + payment;
          expect(parseFloat(generatedBills[billIndex].totalAmount)).toBe(expectedAmounts[payment]);
        }
      }

      // Verify year progression for first payment of each year
      expect(generatedBills[0].startDate).toBe('2024-01-01');
      expect(generatedBills[5].startDate).toBe('2025-01-01');
      expect(generatedBills[10].startDate).toBe('2026-01-01');
      expect(generatedBills[15].startDate).toBe('2027-01-01');
      expect(generatedBills[20].startDate).toBe('2028-01-01');
    });

    it('should handle complex payment plan with seasonal adjustments', async () => {
      // Payment plan: Q1 (high), Q2 (medium), Q3 (low), Q4 (medium)
      const seasonalCosts = ['1200.00', '800.00', '400.00', '800.00'];

      const parentBill = {
        id: 'seasonal-complex',
        buildingId: mockBuilding.id,
        billNumber: 'SEASONAL-COMPLEX-001',
        title: 'Seasonal Services - Multi-Year Contract',
        category: 'utilities',
        vendor: 'Seasonal Services Inc',
        paymentType: 'recurrent',
        schedulePayment: 'quarterly',
        costs: seasonalCosts,
        totalAmount: '3200.00', // Annual total
        startDate: '2024-01-01',
        endDate: '2027-01-01', // 3 years
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(48); // 3 years * 4 quarters * 4 payments per quarter

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify seasonal pattern repeats
      for (let i = 0; i < generatedBills.length; i++) {
        const seasonIndex = i % 4;
        const expectedAmount = parseFloat(seasonalCosts[seasonIndex]);
        expect(parseFloat(generatedBills[i].totalAmount)).toBe(expectedAmount);
      }

      // Verify first bill of each year follows pattern
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(1200); // Q1 2024
      expect(parseFloat(generatedBills[16].totalAmount)).toBe(1200); // Q1 2025  
      expect(parseFloat(generatedBills[32].totalAmount)).toBe(1200); // Q1 2026
    });
  });

  describe('Payment Calculation Edge Cases', () => {
    it('should handle fractional cents properly', async () => {
      const parentBill = {
        id: 'fractional-cents',
        buildingId: mockBuilding.id,
        billNumber: 'FRACTIONAL-001',
        title: 'Bill with Fractional Amounts',
        category: 'other',
        vendor: 'Test Vendor',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['333.33', '333.33', '333.34'], // Adds up to 1000.00
        totalAmount: '1000.00',
        startDate: '2024-01-01',
        endDate: '2024-04-01', // 3 months
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(9); // 3 months * 3 payments per month

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify fractional amounts are preserved
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(333.33);
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(333.33);
      expect(parseFloat(generatedBills[2].totalAmount)).toBe(333.34);

      // Verify pattern repeats
      expect(parseFloat(generatedBills[3].totalAmount)).toBe(333.33);
      expect(parseFloat(generatedBills[4].totalAmount)).toBe(333.33);
      expect(parseFloat(generatedBills[5].totalAmount)).toBe(333.34);
    });

    it('should handle very large payment amounts', async () => {
      const parentBill = {
        id: 'large-amounts',
        buildingId: mockBuilding.id,
        billNumber: 'LARGE-001',
        title: 'Major Infrastructure Investment',
        category: 'maintenance',
        vendor: 'Major Infrastructure Corp',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        costs: ['5000000.00', '3000000.00'], // $5M and $3M
        totalAmount: '8000000.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01',
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(2);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      expect(parseFloat(generatedBills[0].totalAmount)).toBe(5000000);
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(3000000);
    });

    it('should handle single payment (no split)', async () => {
      const parentBill = {
        id: 'single-payment',
        buildingId: mockBuilding.id,
        billNumber: 'SINGLE-001',
        title: 'Single Payment Bill',
        category: 'insurance',
        vendor: 'Insurance Co',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        costs: ['2500.00'], // Single payment
        totalAmount: '2500.00',
        startDate: '2024-01-01',
        endDate: '2026-01-01', // 2 years
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(2); // 2 years, 1 payment each

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Both payments should be the full amount
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(2500);
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(2500);

      // Titles should not show "Part X/Y" for single payments
      expect(generatedBills[0].title).not.toContain('Part');
      expect(generatedBills[1].title).not.toContain('Part');
    });

    it('should handle empty end date (ongoing bills)', async () => {
      const parentBill = {
        id: 'ongoing-bill',
        buildingId: mockBuilding.id,
        billNumber: 'ONGOING-001',
        title: 'Ongoing Monthly Service',
        category: 'cleaning',
        vendor: 'Cleaning Service',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['150.00'],
        totalAmount: '150.00',
        startDate: '2024-01-01',
        endDate: null, // Ongoing
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Should generate for 25 years (300 months)
      expect(result.billsCreated).toBeGreaterThan(250);
      expect(result.billsCreated).toBeLessThan(350);

      // Verify generation until date is 25 years from start
      const generatedUntilDate = new Date(result.generatedUntil);
      const startDate = new Date('2024-01-01');
      const yearsDiff = generatedUntilDate.getFullYear() - startDate.getFullYear();
      expect(yearsDiff).toBe(25);
    });
  });

  describe('Performance and Scale Testing', () => {
    it('should handle bills with many payment installments efficiently', async () => {
      // Create bill with 52 weekly payments (1 year)
      const weeklyCosts = Array(52).fill('100.00');

      const parentBill = {
        id: 'many-installments',
        buildingId: mockBuilding.id,
        billNumber: 'WEEKLY-52-001',
        title: 'Weekly Service - Full Year',
        category: 'cleaning',
        vendor: 'Weekly Service Co',
        paymentType: 'recurrent',
        schedulePayment: 'weekly',
        costs: weeklyCosts,
        totalAmount: '5200.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01',
        createdBy: mockUser.id
      };

      const startTime = Date.now();
      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);
      const duration = Date.now() - startTime;

      expect(result.billsCreated).toBe(2704); // 52 weeks * 52 payments per week
      expect(duration).toBeLessThan(5000); // Should complete within 5 seconds

      // Verify a sample of bills
      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .limit(10);

      generatedBills.forEach(bill => {
        expect(parseFloat(bill.totalAmount)).toBe(100);
        expect(bill.autoGenerated).toBe(true);
        expect(bill.reference).toBe(parentBill.id);
      });
    });

    it('should handle maximum cost array length', async () => {
      // Test with maximum reasonable number of payments (daily for a year)
      const dailyCosts = Array(365).fill('10.00');

      const parentBill = {
        id: 'max-payments',
        buildingId: mockBuilding.id,
        billNumber: 'DAILY-365-001',
        title: 'Daily Service - Full Year',
        category: 'security',
        vendor: 'Daily Security Co',
        paymentType: 'recurrent',
        schedulePayment: 'custom',
        scheduleCustom: Array(365).fill(0).map((_, i) => {
          const date = new Date('2024-01-01');
          date.setDate(date.getDate() + i);
          return date.toISOString().split('T')[0];
        }),
        costs: dailyCosts,
        totalAmount: '3650.00',
        startDate: '2024-01-01',
        endDate: '2024-12-31',
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      expect(result.billsCreated).toBe(365);

      // Verify first and last bills
      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate)
        .limit(1);

      const lastBill = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate, 'desc')
        .limit(1);

      expect(generatedBills[0].startDate).toBe('2024-01-01');
      expect(lastBill[0].startDate).toBe('2024-12-31');
    });
  });
});