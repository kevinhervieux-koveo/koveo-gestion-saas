import { describe, it, expect, beforeEach as _beforeEach, afterEach as _afterEach, jest as _jest, beforeAll, afterAll } from '@jest/globals';
import { billGenerationService } from '../../server/services/bill-generation-service';
import { db } from '../../server/db';
import { bills, users as _users } from '../../shared/schema';
import { eq, and } from 'drizzle-orm';

/**
 * Comprehensive test suite for the Bill Generation Service
 * Tests all aspects of sophisticated bill management including:
 * - Future bill instance generation
 * - Complex payment scenarios (60% now, 40% later)
 * - Multiple payment plans and installments
 * - Parent-child bill relationships
 * - 25-year projection capabilities
 * - Auto-generated bill management.
 */

describe('BillGenerationService', () => {
  const mockSystemUser = {
    id: 'test-user-123',
    email: 'system@test.com',
    role: 'admin'
  };

  const mockBuilding = {
    id: 'building-123',
    organizationId: 'org-123'
  };

  beforeAll(async () => {
    // Clean up any existing test data
    await db.delete(bills).where(eq(bills.buildingId, mockBuilding.id));
  });

  afterAll(async () => {
    // Clean up test data
    await db.delete(bills).where(eq(bills.buildingId, mockBuilding.id));
  });

  describe('generateFutureBillInstances', () => {
    it('should generate monthly recurring bill instances for 25 years', async () => {
      const parentBill = {
        id: 'parent-bill-1',
        buildingId: mockBuilding.id,
        billNumber: 'MONTHLY-2024-001',
        title: 'Monthly Maintenance Fee',
        description: 'Regular building maintenance',
        category: 'maintenance',
        vendor: 'Maintenance Corp',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        scheduleCustom: null,
        costs: ['1200.00'],
        totalAmount: '1200.00',
        startDate: '2024-01-01',
        endDate: null,
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockSystemUser.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Should generate approximately 300 bills (25 years * 12 months)
      expect(result.billsCreated).toBeGreaterThan(250);
      expect(result.billsCreated).toBeLessThan(350);
      expect(result.generatedUntil).toBeDefined();

      // Verify bills were actually created in database
      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      expect(generatedBills.length).toBe(result.billsCreated);
      
      // Check first generated bill properties
      const firstBill = generatedBills[0];
      expect(firstBill.title).toContain('Monthly Maintenance Fee');
      expect(firstBill.paymentType).toBe('unique');
      expect(firstBill.autoGenerated).toBe(true);
      expect(firstBill.reference).toBe(parentBill.id);
      expect(firstBill.billNumber).toMatch(/MONTHLY-2024-001-\d{4}-\d{2}/);
    });

    it('should handle complex payment scenarios - 60% now, 40% in 2 months', async () => {
      const parentBill = {
        id: 'parent-bill-complex',
        buildingId: mockBuilding.id,
        billNumber: 'COMPLEX-2024-001',
        title: 'Annual Insurance Premium',
        description: 'Split payment insurance',
        category: 'insurance',
        vendor: 'Insurance Corp',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        scheduleCustom: null,
        costs: ['6000.00', '4000.00'], // 60% now, 40% later
        totalAmount: '10000.00',
        startDate: '2024-01-01',
        endDate: '2029-01-01', // 5 years
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockSystemUser.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Should generate 10 bills (5 years * 2 payments per year)
      expect(result.billsCreated).toBe(10);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify payment amounts and timing
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(6000); // First payment 60%
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(4000); // Second payment 40%
      
      // Verify payment dates are 1 month apart
      const firstDate = new Date(generatedBills[0].startDate);
      const secondDate = new Date(generatedBills[1].startDate);
      const monthsDiff = (secondDate.getFullYear() - firstDate.getFullYear()) * 12 + 
                        (secondDate.getMonth() - firstDate.getMonth());
      expect(monthsDiff).toBe(1);

      // Verify bill titles indicate payment parts
      expect(generatedBills[0].title).toContain('Part 1/2');
      expect(generatedBills[1].title).toContain('Part 2/2');
    });

    it('should handle quarterly payments with custom dates', async () => {
      const parentBill = {
        id: 'parent-bill-quarterly',
        buildingId: mockBuilding.id,
        billNumber: 'QUARTERLY-2024-001',
        title: 'Quarterly Utilities',
        description: 'Seasonal utility payments',
        category: 'utilities',
        vendor: 'Utility Corp',
        paymentType: 'recurrent',
        schedulePayment: 'custom',
        scheduleCustom: ['2024-03-15', '2024-06-15', '2024-09-15', '2024-12-15'],
        costs: ['800.00'],
        totalAmount: '800.00',
        startDate: '2024-01-01',
        endDate: '2026-12-31', // 3 years
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockSystemUser.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Should generate 12 bills (3 years * 4 quarters)
      expect(result.billsCreated).toBe(12);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify custom dates are respected
      expect(generatedBills[0].startDate).toBe('2024-03-15');
      expect(generatedBills[1].startDate).toBe('2024-06-15');
      expect(generatedBills[2].startDate).toBe('2024-09-15');
      expect(generatedBills[3].startDate).toBe('2024-12-15');
    });

    it('should handle weekly recurring payments', async () => {
      const parentBill = {
        id: 'parent-bill-weekly',
        buildingId: mockBuilding.id,
        billNumber: 'WEEKLY-2024-001',
        title: 'Weekly Cleaning Service',
        description: 'Regular cleaning',
        category: 'cleaning',
        vendor: 'Clean Corp',
        paymentType: 'recurrent',
        schedulePayment: 'weekly',
        scheduleCustom: null,
        costs: ['150.00'],
        totalAmount: '150.00',
        startDate: '2024-01-01',
        endDate: '2024-03-31', // 3 months to limit test data
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockSystemUser.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Should generate approximately 13 bills (3 months * 4.33 weeks per month)
      expect(result.billsCreated).toBeGreaterThan(10);
      expect(result.billsCreated).toBeLessThan(16);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Verify weekly intervals
      const firstDate = new Date(generatedBills[0].startDate);
      const secondDate = new Date(generatedBills[1].startDate);
      const daysDiff = (secondDate.getTime() - firstDate.getTime()) / (1000 * 60 * 60 * 24);
      expect(daysDiff).toBe(7);
    });

    it('should reject non-recurrent bills', async () => {
      const uniqueBill = {
        id: 'unique-bill-1',
        buildingId: mockBuilding.id,
        paymentType: 'unique',
        schedulePayment: null,
        title: 'One-time bill'
      };

      await expect(
        billGenerationService.generateFutureBillInstances(uniqueBill as any)
      ).rejects.toThrow('Only recurrent bills can generate future instances');
    });

    it('should clean up existing generated bills before creating new ones', async () => {
      const parentBill = {
        id: 'parent-bill-cleanup',
        buildingId: mockBuilding.id,
        billNumber: 'CLEANUP-2024-001',
        title: 'Test Cleanup Bill',
        description: 'Testing cleanup',
        category: 'maintenance',
        vendor: 'Test Corp',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        scheduleCustom: null,
        costs: ['500.00'],
        totalAmount: '500.00',
        startDate: '2024-01-01',
        endDate: '2024-06-30', // 6 months
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockSystemUser.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // Generate bills first time
      const firstResult = await billGenerationService.generateFutureBillInstances(parentBill as any);
      expect(firstResult.billsCreated).toBe(6);

      // Generate again - should clean up and recreate
      const secondResult = await billGenerationService.generateFutureBillInstances(parentBill as any);
      expect(secondResult.billsCreated).toBe(6);

      // Should still only have 6 bills total, not 12
      const finalBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      expect(finalBills.length).toBe(6);
    });
  });

  describe('updateGeneratedBillsFromParent', () => {
    it('should update all generated bills when parent is modified', async () => {
      const parentBill = {
        id: 'parent-bill-update',
        buildingId: mockBuilding.id,
        billNumber: 'UPDATE-2024-001',
        title: 'Original Title',
        description: 'Original description',
        category: 'maintenance',
        vendor: 'Original Vendor',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        scheduleCustom: null,
        costs: ['300.00'],
        totalAmount: '300.00',
        startDate: '2024-01-01',
        endDate: '2024-04-30', // 4 months
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockSystemUser.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // Generate initial bills
      await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Update parent bill information
      const updates = {
        title: 'Updated Title',
        category: 'utilities',
        vendor: 'New Vendor Corp',
        notes: 'Updated via cascade'
      };

      const result = await billGenerationService.updateGeneratedBillsFromParent(
        parentBill.id, 
        updates
      );

      expect(result.billsUpdated).toBe(4);

      // Verify bills were updated
      const updatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      updatedBills.forEach(bill => {
        expect(bill.title).toContain('Updated Title');
        expect(bill.category).toBe('utilities');
        expect(bill.vendor).toBe('New Vendor Corp');
        expect(bill.notes).toContain('Updated via cascade');
      });
    });

    it('should preserve date and part information in titles when updating', async () => {
      const parentBill = {
        id: 'parent-bill-title-preserve',
        buildingId: mockBuilding.id,
        billNumber: 'PRESERVE-2024-001',
        title: 'Original Complex Bill',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        costs: ['2000.00', '1000.00'], // Two payments
        totalAmount: '3000.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01',
        createdBy: mockSystemUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const updates = { title: 'Updated Complex Bill' };
      await billGenerationService.updateGeneratedBillsFromParent(parentBill.id, updates);

      const updatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      // Should preserve the date and part information
      expect(updatedBills[0].title).toMatch(/Updated Complex Bill - .* \(Part 1\/2\)/);
      expect(updatedBills[1].title).toMatch(/Updated Complex Bill - .* \(Part 2\/2\)/);
    });
  });

  describe('markBillAsPaid', () => {
    it('should mark a bill as paid with payment date', async () => {
      const testBill = {
        id: 'test-bill-paid',
        buildingId: mockBuilding.id,
        billNumber: 'PAID-2024-001',
        title: 'Test Payment Bill',
        status: 'sent',
        totalAmount: '500.00',
        autoGenerated: true,
        reference: 'parent-bill-id',
        createdBy: mockSystemUser.id
      };

      // Insert test bill
      await db.insert(bills).values(testBill as any);

      const paymentDate = new Date('2024-02-15');
      await billGenerationService.markBillAsPaid(testBill.id, paymentDate);

      // Verify bill was marked as paid
      const [updatedBill] = await db
        .select()
        .from(bills)
        .where(eq(bills.id, testBill.id));

      expect(updatedBill.status).toBe('paid');
      expect(updatedBill.notes).toContain('Payment confirmed on 2/15/2024');
    });

    it('should use current date when no payment date provided', async () => {
      const testBill = {
        id: 'test-bill-paid-auto',
        buildingId: mockBuilding.id,
        billNumber: 'PAID-AUTO-2024-001',
        title: 'Auto Date Payment Bill',
        status: 'sent',
        totalAmount: '750.00',
        autoGenerated: true,
        reference: 'parent-bill-id',
        createdBy: mockSystemUser.id
      };

      await db.insert(bills).values(testBill as any);

      await billGenerationService.markBillAsPaid(testBill.id);

      const [updatedBill] = await db
        .select()
        .from(bills)
        .where(eq(bills.id, testBill.id));

      expect(updatedBill.status).toBe('paid');
      expect(updatedBill.notes).toContain('Payment confirmed on');
    });
  });

  describe('getGeneratedBillsStats', () => {
    it('should return comprehensive statistics for generated bills', async () => {
      const parentBill = {
        id: 'parent-bill-stats',
        buildingId: mockBuilding.id,
        billNumber: 'STATS-2024-001',
        title: 'Statistics Test Bill',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['400.00'],
        totalAmount: '400.00',
        startDate: '2024-01-01',
        endDate: '2024-06-30', // 6 months
        createdBy: mockSystemUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Mark some bills as paid
      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      // Mark first 2 bills as paid
      for (let i = 0; i < 2; i++) {
        await billGenerationService.markBillAsPaid(generatedBills[i].id);
      }

      const stats = await billGenerationService.getGeneratedBillsStats(parentBill.id);

      expect(stats.totalGenerated).toBe(6);
      expect(stats.paidBills).toBe(2);
      expect(stats.pendingBills).toBeGreaterThan(0);
      expect(stats.futureBills).toBeGreaterThan(0);
      expect(stats.totalAmount).toBe(2400); // 6 bills * $400
      expect(stats.paidAmount).toBe(800); // 2 bills * $400
    });

    it('should categorize bills by date correctly', async () => {
      const today = new Date();
      const pastDate = new Date(today);
      pastDate.setMonth(pastDate.getMonth() - 1);
      const futureDate = new Date(today);
      futureDate.setMonth(futureDate.getMonth() + 1);

      const parentBill = {
        id: 'parent-bill-date-stats',
        buildingId: mockBuilding.id,
        billNumber: 'DATE-STATS-2024-001',
        title: 'Date Statistics Test',
        paymentType: 'recurrent',
        schedulePayment: 'custom',
        scheduleCustom: [
          pastDate.toISOString().split('T')[0],
          today.toISOString().split('T')[0],
          futureDate.toISOString().split('T')[0]
        ],
        costs: ['200.00'],
        totalAmount: '200.00',
        startDate: pastDate.toISOString().split('T')[0],
        endDate: futureDate.toISOString().split('T')[0],
        createdBy: mockSystemUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const stats = await billGenerationService.getGeneratedBillsStats(parentBill.id);

      expect(stats.totalGenerated).toBe(3);
      expect(stats.futureBills).toBe(1); // Only future date bill
      expect(stats.pendingBills).toBe(2); // Past and today bills
    });
  });

  describe('deleteGeneratedBills', () => {
    it('should delete only unpaid bills by default', async () => {
      const parentBill = {
        id: 'parent-bill-delete',
        buildingId: mockBuilding.id,
        billNumber: 'DELETE-2024-001',
        title: 'Delete Test Bill',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['350.00'],
        totalAmount: '350.00',
        startDate: '2024-01-01',
        endDate: '2024-05-31', // 5 months
        createdBy: mockSystemUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      // Mark first bill as paid
      await billGenerationService.markBillAsPaid(generatedBills[0].id);

      const result = await billGenerationService.deleteGeneratedBills(parentBill.id, false);

      // Should delete 4 unpaid bills, keep 1 paid bill
      expect(result.billsDeleted).toBe(4);

      const remainingBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      expect(remainingBills.length).toBe(1);
      expect(remainingBills[0].status).toBe('paid');
    });

    it('should delete all future bills when deleteAllFuture is true', async () => {
      const parentBill = {
        id: 'parent-bill-delete-all',
        buildingId: mockBuilding.id,
        billNumber: 'DELETE-ALL-2024-001',
        title: 'Delete All Test Bill',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['250.00'],
        totalAmount: '250.00',
        startDate: '2024-06-01', // Future date
        endDate: '2024-10-31', // 5 months in future
        createdBy: mockSystemUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      // Mark first bill as paid
      await billGenerationService.markBillAsPaid(generatedBills[0].id);

      const result = await billGenerationService.deleteGeneratedBills(parentBill.id, true);

      // Should delete all bills including paid ones (since they're in the future)
      expect(result.billsDeleted).toBe(5);

      const remainingBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      expect(remainingBills.length).toBe(0);
    });
  });

  describe('Edge Cases and Error Handling', () => {
    it('should handle bills with no costs array', async () => {
      const invalidBill = {
        id: 'invalid-bill-1',
        buildingId: mockBuilding.id,
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: [], // Empty costs array
        startDate: '2024-01-01',
        endDate: '2024-03-31',
        createdBy: mockSystemUser.id
      };

      await expect(
        billGenerationService.generateFutureBillInstances(invalidBill as any)
      ).rejects.toThrow();
    });

    it('should handle very long projection periods safely', async () => {
      const longTermBill = {
        id: 'long-term-bill',
        buildingId: mockBuilding.id,
        billNumber: 'LONG-2024-001',
        title: 'Long Term Bill',
        paymentType: 'recurrent',
        schedulePayment: 'weekly',
        costs: ['50.00'],
        totalAmount: '50.00',
        startDate: '2024-01-01',
        endDate: null, // No end date - should limit to 25 years
        createdBy: mockSystemUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(longTermBill as any);

      // Should not generate more than 10,000 bills (safety limit)
      expect(result.billsCreated).toBeLessThan(10000);
      expect(result.billsCreated).toBeGreaterThan(1000); // But should generate many for 25 years
    });

    it('should handle invalid schedule types gracefully', async () => {
      const invalidScheduleBill = {
        id: 'invalid-schedule-bill',
        buildingId: mockBuilding.id,
        paymentType: 'recurrent',
        schedulePayment: 'invalid-schedule',
        costs: ['100.00'],
        startDate: '2024-01-01',
        endDate: '2024-12-31',
        createdBy: mockSystemUser.id
      };

      await expect(
        billGenerationService.generateFutureBillInstances(invalidScheduleBill as any)
      ).rejects.toThrow('Unknown schedule type: invalid-schedule');
    });

    it('should handle concurrent generation requests', async () => {
      const parentBill = {
        id: 'concurrent-bill',
        buildingId: mockBuilding.id,
        billNumber: 'CONCURRENT-2024-001',
        title: 'Concurrent Test Bill',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['100.00'],
        totalAmount: '100.00',
        startDate: '2024-01-01',
        endDate: '2024-06-30',
        createdBy: mockSystemUser.id
      };

      // Run generation concurrently
      const [result1, result2] = await Promise.all([
        billGenerationService.generateFutureBillInstances(parentBill as any),
        billGenerationService.generateFutureBillInstances(parentBill as any)
      ]);

      // Both should succeed, but only one set of bills should exist
      expect(result1.billsCreated).toBe(6);
      expect(result2.billsCreated).toBe(6);

      const finalBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      // Should not have duplicates
      expect(finalBills.length).toBe(6);
    });
  });
});