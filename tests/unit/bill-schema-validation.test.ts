import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { z } from 'zod';
import { createInsertSchema } from 'drizzle-zod';
import { bills } from '../../shared/schemas/financial';
import { db } from '../../server/db';
import { eq, and } from 'drizzle-orm';

/**
 * Comprehensive test suite for Bill Schema Validation
 * Tests all aspects of the enhanced bills table including:
 * - Basic schema validation
 * - Auto-generation flags and references
 * - Parent-child relationships
 * - Payment type validations
 * - Schedule and cost validations
 * - Complex payment scenarios.
 */

describe('Bill Schema Validation', () => {
  // Create insert schema for validation
  const insertBillSchema = createInsertSchema(bills);
  
  const validBaseBill = {
    buildingId: '123e4567-e89b-12d3-a456-426614174000',
    billNumber: 'TEST-2024-001',
    title: 'Test Bill',
    description: 'Test description',
    category: 'maintenance' as const,
    vendor: 'Test Vendor',
    paymentType: 'unique' as const,
    costs: ['500.00'] as string[],
    totalAmount: '500.00',
    startDate: '2024-01-01',
    status: 'draft' as const,
    createdBy: '123e4567-e89b-12d3-a456-426614174001'
  };

  beforeEach(async () => {
    // Clean up test data
    await db.delete(bills).where(eq(bills.billNumber, 'TEST-2024-001'));
  });

  afterEach(async () => {
    // Clean up test data
    await db.delete(bills).where(eq(bills.billNumber, 'TEST-2024-001'));
  });

  describe('Basic Schema Validation', () => {
    it('should validate a complete valid bill', () => {
      const result = insertBillSchema.safeParse(validBaseBill);
      expect(result.success).toBe(true);
      
      if (result.success) {
        expect(result.data.buildingId).toBe(validBaseBill.buildingId);
        expect(result.data.title).toBe(validBaseBill.title);
        expect(result.data.paymentType).toBe('unique');
      }
    });

    it('should require mandatory fields', () => {
      const incompleteBill = {
        title: 'Incomplete Bill'
        // Missing required fields
      };

      const result = insertBillSchema.safeParse(incompleteBill);
      expect(result.success).toBe(false);
      
      if (!result.success) {
        const fieldErrors = result.error.issues.map(issue => issue.path[0]);
        expect(fieldErrors).toContain('buildingId');
        expect(fieldErrors).toContain('billNumber');
        expect(fieldErrors).toContain('category');
        expect(fieldErrors).toContain('paymentType');
        expect(fieldErrors).toContain('costs');
        expect(fieldErrors).toContain('totalAmount');
        expect(fieldErrors).toContain('startDate');
      }
    });

    it('should validate UUID fields', () => {
      const billWithInvalidUUID = {
        ...validBaseBill,
        buildingId: 'invalid-uuid',
        createdBy: 'also-invalid'
      };

      const result = insertBillSchema.safeParse(billWithInvalidUUID);
      expect(result.success).toBe(false);
      
      if (!result.success) {
        const uuidErrors = result.error.issues.filter(
          issue => issue.path[0] === 'buildingId' || issue.path[0] === 'createdBy'
        );
        expect(uuidErrors.length).toBeGreaterThan(0);
      }
    });

    it('should validate date fields', () => {
      const billWithInvalidDate = {
        ...validBaseBill,
        startDate: 'invalid-date',
        endDate: 'also-invalid'
      };

      const result = insertBillSchema.safeParse(billWithInvalidDate);
      expect(result.success).toBe(false);
      
      if (!result.success) {
        const dateErrors = result.error.issues.filter(
          issue => issue.path[0] === 'startDate' || issue.path[0] === 'endDate'
        );
        expect(dateErrors.length).toBeGreaterThan(0);
      }
    });

    it('should validate decimal precision for amounts', () => {
      const billWithInvalidAmount = {
        ...validBaseBill,
        totalAmount: '999999999999999.999', // Exceeds precision
        costs: ['999999999999999.999']
      };

      const result = insertBillSchema.safeParse(billWithInvalidAmount);
      expect(result.success).toBe(false);
    });
  });

  describe('Auto-Generation Schema Validation', () => {
    it('should validate auto-generated flag defaults to false', () => {
      const bill = { ...validBaseBill };
      const result = insertBillSchema.safeParse(bill);
      
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.autoGenerated).toBe(false);
      }
    });

    it('should allow auto-generated flag to be set explicitly', () => {
      const autoGeneratedBill = {
        ...validBaseBill,
        autoGenerated: true,
        reference: '123e4567-e89b-12d3-a456-426614174002'
      };

      const result = insertBillSchema.safeParse(autoGeneratedBill);
      expect(result.success).toBe(true);
      
      if (result.success) {
        expect(result.data.autoGenerated).toBe(true);
        expect(result.data.reference).toBe(autoGeneratedBill.reference);
      }
    });

    it('should validate reference as valid UUID when provided', () => {
      const billWithInvalidReference = {
        ...validBaseBill,
        autoGenerated: true,
        reference: 'invalid-reference-id'
      };

      const result = insertBillSchema.safeParse(billWithInvalidReference);
      expect(result.success).toBe(false);
      
      if (!result.success) {
        const referenceErrors = result.error.issues.filter(
          issue => issue.path[0] === 'reference'
        );
        expect(referenceErrors.length).toBeGreaterThan(0);
      }
    });

    it('should allow null reference for non-auto-generated bills', () => {
      const manualBill = {
        ...validBaseBill,
        autoGenerated: false,
        reference: null
      };

      const result = insertBillSchema.safeParse(manualBill);
      expect(result.success).toBe(true);
      
      if (result.success) {
        expect(result.data.reference).toBeNull();
      }
    });
  });

  describe('Payment Type Validation', () => {
    it('should validate unique payment type', () => {
      const uniqueBill = {
        ...validBaseBill,
        paymentType: 'unique',
        schedulePayment: null,
        scheduleCustom: null
      };

      const result = insertBillSchema.safeParse(uniqueBill);
      expect(result.success).toBe(true);
    });

    it('should validate recurrent payment type', () => {
      const recurrentBill = {
        ...validBaseBill,
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        endDate: '2024-12-31'
      };

      const result = insertBillSchema.safeParse(recurrentBill);
      expect(result.success).toBe(true);
    });

    it('should reject invalid payment types', () => {
      const invalidPaymentBill = {
        ...validBaseBill,
        paymentType: 'invalid-type'
      };

      const result = insertBillSchema.safeParse(invalidPaymentBill);
      expect(result.success).toBe(false);
    });
  });

  describe('Schedule Validation', () => {
    it('should validate standard schedule types', () => {
      const scheduleTypes = ['weekly', 'monthly', 'quarterly', 'yearly', 'custom'];
      
      scheduleTypes.forEach(scheduleType => {
        const scheduledBill = {
          ...validBaseBill,
          paymentType: 'recurrent',
          schedulePayment: scheduleType
        };

        const result = insertBillSchema.safeParse(scheduledBill);
        expect(result.success).toBe(true);
      });
    });

    it('should validate custom schedule with dates array', () => {
      const customScheduleBill = {
        ...validBaseBill,
        paymentType: 'recurrent',
        schedulePayment: 'custom',
        scheduleCustom: ['2024-03-15', '2024-06-15', '2024-09-15', '2024-12-15']
      };

      const result = insertBillSchema.safeParse(customScheduleBill);
      expect(result.success).toBe(true);
    });

    it('should reject invalid schedule types', () => {
      const invalidScheduleBill = {
        ...validBaseBill,
        paymentType: 'recurrent',
        schedulePayment: 'invalid-schedule'
      };

      const result = insertBillSchema.safeParse(invalidScheduleBill);
      expect(result.success).toBe(false);
    });

    it('should validate custom dates format', () => {
      const invalidCustomDatesBill = {
        ...validBaseBill,
        paymentType: 'recurrent',
        schedulePayment: 'custom',
        scheduleCustom: ['invalid-date', '2024-13-40'] // Invalid dates
      };

      const result = insertBillSchema.safeParse(invalidCustomDatesBill);
      expect(result.success).toBe(false);
    });
  });

  describe('Costs Array Validation', () => {
    it('should validate single cost entry', () => {
      const singleCostBill = {
        ...validBaseBill,
        costs: ['1000.00'],
        totalAmount: '1000.00'
      };

      const result = insertBillSchema.safeParse(singleCostBill);
      expect(result.success).toBe(true);
    });

    it('should validate multiple cost entries for split payments', () => {
      const multiCostBill = {
        ...validBaseBill,
        costs: ['600.00', '400.00'],
        totalAmount: '1000.00'
      };

      const result = insertBillSchema.safeParse(multiCostBill);
      expect(result.success).toBe(true);
    });

    it('should validate complex payment scenarios', () => {
      const complexPaymentBill = {
        ...validBaseBill,
        costs: ['3000.00', '2500.00', '2000.00', '1500.00'], // Quarterly declining payments
        totalAmount: '9000.00',
        paymentType: 'recurrent',
        schedulePayment: 'quarterly'
      };

      const result = insertBillSchema.safeParse(complexPaymentBill);
      expect(result.success).toBe(true);
    });

    it('should reject empty costs array', () => {
      const emptyCostsBill = {
        ...validBaseBill,
        costs: []
      };

      const result = insertBillSchema.safeParse(emptyCostsBill);
      expect(result.success).toBe(false);
    });

    it('should validate decimal format in costs', () => {
      const invalidDecimalBill = {
        ...validBaseBill,
        costs: ['invalid-amount', '100.999999'] // Invalid format and too many decimal places
      };

      const result = insertBillSchema.safeParse(invalidDecimalBill);
      expect(result.success).toBe(false);
    });
  });

  describe('Category Validation', () => {
    it('should validate all supported bill categories', () => {
      const validCategories = [
        'insurance', 'maintenance', 'salary', 'utilities', 'cleaning',
        'security', 'landscaping', 'professional_services', 'administration',
        'repairs', 'supplies', 'taxes', 'other'
      ];

      validCategories.forEach(category => {
        const categorizedBill = {
          ...validBaseBill,
          category
        };

        const result = insertBillSchema.safeParse(categorizedBill);
        expect(result.success).toBe(true);
      });
    });

    it('should reject invalid categories', () => {
      const invalidCategoryBill = {
        ...validBaseBill,
        category: 'invalid-category'
      };

      const result = insertBillSchema.safeParse(invalidCategoryBill);
      expect(result.success).toBe(false);
    });
  });

  describe('Status Validation', () => {
    it('should validate all bill statuses', () => {
      const validStatuses = ['draft', 'sent', 'paid', 'overdue', 'cancelled'];

      validStatuses.forEach(status => {
        const statusBill = {
          ...validBaseBill,
          status
        };

        const result = insertBillSchema.safeParse(statusBill);
        expect(result.success).toBe(true);
      });
    });

    it('should default status to draft', () => {
      const billWithoutStatus = { ...validBaseBill };
      delete billWithoutStatus.status;

      const result = insertBillSchema.safeParse(billWithoutStatus);
      expect(result.success).toBe(true);
      
      if (result.success) {
        expect(result.data.status).toBe('draft');
      }
    });

    it('should reject invalid statuses', () => {
      const invalidStatusBill = {
        ...validBaseBill,
        status: 'invalid-status'
      };

      const result = insertBillSchema.safeParse(invalidStatusBill);
      expect(result.success).toBe(false);
    });
  });

  describe('Database Integration Validation', () => {
    it('should successfully insert a valid bill into database', async () => {
      const testBill = {
        ...validBaseBill,
        billNumber: 'DB-TEST-2024-001'
      };

      const result = insertBillSchema.safeParse(testBill);
      expect(result.success).toBe(true);

      if (result.success) {
        const [insertedBill] = await db.insert(bills).values([result.data]).returning();
        
        expect(insertedBill.id).toBeDefined();
        expect(insertedBill.billNumber).toBe('DB-TEST-2024-001');
        expect(insertedBill.autoGenerated).toBe(false);
        expect(insertedBill.reference).toBeNull();
        expect(insertedBill.createdAt).toBeDefined();
        expect(insertedBill.updatedAt).toBeDefined();

        // Clean up
        await db.delete(bills).where(eq(bills.id, insertedBill.id));
      }
    });

    it('should handle auto-generated bill with reference', async () => {
      // First create a parent bill
      const parentBill = {
        ...validBaseBill,
        billNumber: 'PARENT-2024-001'
      };

      const [parent] = await db.insert(bills).values([parentBill]).returning();

      // Now create auto-generated child bill
      const childBill = {
        ...validBaseBill,
        billNumber: 'CHILD-2024-001',
        autoGenerated: true,
        reference: parent.id
      };

      const [child] = await db.insert(bills).values([childBill]).returning();

      expect(child.autoGenerated).toBe(true);
      expect(child.reference).toBe(parent.id);

      // Verify relationship can be queried
      const childWithParent = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.id, child.id),
          eq(bills.reference, parent.id)
        ));

      expect(childWithParent.length).toBe(1);
      expect(childWithParent[0].reference).toBe(parent.id);

      // Clean up
      await db.delete(bills).where(eq(bills.id, child.id));
      await db.delete(bills).where(eq(bills.id, parent.id));
    });

    it('should enforce unique bill numbers', async () => {
      const duplicateBill1 = {
        ...validBaseBill,
        billNumber: 'UNIQUE-TEST-001'
      };

      const duplicateBill2 = {
        ...validBaseBill,
        billNumber: 'UNIQUE-TEST-001' // Same bill number
      };

      // Insert first bill
      const [firstBill] = await db.insert(bills).values([duplicateBill1]).returning();
      expect(firstBill.id).toBeDefined();

      // Attempt to insert second bill with same number should fail
      await expect(
        db.insert(bills).values([duplicateBill2])
      ).rejects.toThrow();

      // Clean up
      await db.delete(bills).where(eq(bills.id, firstBill.id));
    });

    it('should handle bills with complex payment structures', async () => {
      const complexBill = {
        ...validBaseBill,
        billNumber: 'COMPLEX-2024-001',
        title: 'Complex Annual Insurance - Split Payment',
        paymentType: 'recurrent',
        schedulePayment: 'custom',
        scheduleCustom: ['2024-01-15', '2024-07-15'], // Bi-annual
        costs: ['6000.00', '4000.00'], // 60% first, 40% second
        totalAmount: '10000.00',
        endDate: '2025-01-15'
      };

      const [insertedBill] = await db.insert(bills).values([complexBill]).returning();

      expect(insertedBill.paymentType).toBe('recurrent');
      expect(insertedBill.schedulePayment).toBe('custom');
      expect(insertedBill.scheduleCustom).toEqual(['2024-01-15', '2024-07-15']);
      expect(insertedBill.costs).toEqual(['6000.00', '4000.00']);
      expect(parseFloat(insertedBill.totalAmount)).toBe(10000);

      // Clean up
      await db.delete(bills).where(eq(bills.id, insertedBill.id));
    });

    it('should handle bills with extensive metadata', async () => {
      const metadataBill = {
        ...validBaseBill,
        billNumber: 'METADATA-2024-001',
        documentPath: '/documents/bills/metadata-test.pdf',
        documentName: 'Annual_Maintenance_Contract_2024.pdf',
        isAiAnalyzed: true,
        aiAnalysisData: {
          extractedAmount: 5000,
          confidence: 0.95,
          vendor: 'AI Detected Vendor',
          dueDate: '2024-06-30',
          categories: ['maintenance', 'hvac']
        },
        notes: 'This bill was processed by AI analysis system with high confidence.'
      };

      const [insertedBill] = await db.insert(bills).values([metadataBill]).returning();

      expect(insertedBill.documentPath).toBe('/documents/bills/metadata-test.pdf');
      expect(insertedBill.isAiAnalyzed).toBe(true);
      expect(insertedBill.aiAnalysisData).toEqual(metadataBill.aiAnalysisData);
      expect(insertedBill.notes).toContain('AI analysis system');

      // Clean up
      await db.delete(bills).where(eq(bills.id, insertedBill.id));
    });
  });

  describe('Business Logic Validation', () => {
    it('should validate logical consistency between total amount and costs', () => {
      // This would typically be handled by business logic rather than schema
      // but we can test the data structure supports it
      const inconsistentBill = {
        ...validBaseBill,
        costs: ['100.00', '200.00'], // Sum = 300
        totalAmount: '500.00' // Doesn't match sum
      };

      // Schema allows this - business logic should validate
      const result = insertBillSchema.safeParse(inconsistentBill);
      expect(result.success).toBe(true);

      // Business validation function (would be implemented separately)
      const validateCostTotal = (costs: string[], total: string) => {
        const costsSum = costs.reduce((sum, cost) => sum + parseFloat(cost), 0);
        return Math.abs(costsSum - parseFloat(total)) < 0.01; // Allow for rounding
      };

      expect(validateCostTotal(inconsistentBill.costs, inconsistentBill.totalAmount)).toBe(false);
    });

    it('should support bills with future start dates', () => {
      const futureDate = new Date();
      futureDate.setFullYear(futureDate.getFullYear() + 1);

      const futureBill = {
        ...validBaseBill,
        startDate: futureDate.toISOString().split('T')[0]
      };

      const result = insertBillSchema.safeParse(futureBill);
      expect(result.success).toBe(true);
    });

    it('should support bills with end dates before start dates (for validation)', () => {
      const invalidDateRangeBill = {
        ...validBaseBill,
        startDate: '2024-12-31',
        endDate: '2024-01-01' // End before start
      };

      // Schema allows this - business logic should validate
      const result = insertBillSchema.safeParse(invalidDateRangeBill);
      expect(result.success).toBe(true);

      // Business validation
      const validateDateRange = (start: string, end: string | null) => {
        if (!end) {return true;}
        return new Date(start) <= new Date(end);
      };

      expect(validateDateRange(invalidDateRangeBill.startDate, invalidDateRangeBill.endDate)).toBe(false);
    });
  });
});