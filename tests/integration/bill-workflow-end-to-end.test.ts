import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import request from 'supertest';
import express from 'express';
import { db } from '../../server/db';
import { bills } from '../../shared/schemas/financial';
import { billGenerationService } from '../../server/services/bill-generation-service';
import { registerBillRoutes } from '../../server/api/bills';
import { eq, and } from 'drizzle-orm';

/**
 * Comprehensive End-to-End Integration Tests for Bill Workflow
 * Tests the complete sophisticated bill management workflow including:
 * - Creating recurrent bills with complex payment plans
 * - Generating future bill instances (up to 25 years)
 * - Managing payment confirmations
 * - Updating parent bills with cascade to children
 * - Deleting bills with cascade options
 * - Real API integration with database
 * - Error handling and edge cases
 * - Performance validation.
 */

// Mock authentication
jest.mock('../../server/auth', () => ({
  requireAuth: (req: unknown, res: unknown, next: unknown) => {
    req.user = { 
      id: 'e2e-user-123', 
      role: 'admin',
      canAccessAllOrganizations: true,
      organizations: ['e2e-org-123']
    };
    next();
  }
}));

describe('Bill Workflow End-to-End Integration Tests', () => {
  let app: express.Application;
  const mockBuilding = { id: 'building-e2e-test', organizationId: 'e2e-org-123' };
  const mockUser = { id: 'e2e-user-123' };

  beforeEach(async () => {
    app = express();
    app.use(express.json());
    registerBillRoutes(app);

    // Clean up test data
    await db.delete(bills).where(eq(bills.buildingId, mockBuilding.id));
    
    // Set up mock bills array for API
    global.mockBills = [];
  });

  afterEach(async () => {
    await db.delete(bills).where(eq(bills.buildingId, mockBuilding.id));
    global.mockBills = [];
  });

  describe('Complete Recurrent Bill Lifecycle', () => {
    it('should handle full lifecycle: create -> generate -> update -> pay -> delete', async () => {
      // Step 1: Create recurrent bill (simulated via mock)
      const parentBill = {
        id: 'e2e-lifecycle-bill',
        buildingId: mockBuilding.id,
        billNumber: 'E2E-LIFECYCLE-001',
        title: 'Annual Insurance - Monthly Payments',
        description: 'Complete lifecycle test bill',
        category: 'insurance',
        vendor: 'Insurance Corporation',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        scheduleCustom: null,
        costs: Array(12).fill('500.00'), // 12 monthly payments
        totalAmount: '6000.00',
        startDate: '2024-01-01',
        endDate: '2026-01-01', // 2 years
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockUser.id
      };

      global.mockBills = [parentBill];

      // Step 2: Generate future bill instances via API
      const generateResponse = await request(app)
        .post(`/api/bills/${parentBill.id}/generate-future`)
        .expect(200);

      expect(generateResponse.body.message).toBe('Future bills generated successfully');
      expect(generateResponse.body.billsCreated).toBe(24); // 2 years * 12 payments
      expect(generateResponse.body.parentBill.id).toBe(parentBill.id);

      // Verify bills were created in database
      const generatedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ))
        .orderBy(bills.startDate);

      expect(generatedBills.length).toBe(24);

      // Step 3: Get statistics
      const statsResponse = await request(app)
        .get(`/api/bills/${parentBill.id}/generated-stats`)
        .expect(200);

      expect(statsResponse.body.generatedBills.totalGenerated).toBe(24);
      expect(statsResponse.body.generatedBills.totalAmount).toBe(12000); // 24 * $500
      expect(statsResponse.body.generatedBills.paidBills).toBe(0);

      // Step 4: Mark some bills as paid via API
      const billsToMarkPaid = generatedBills.slice(0, 6); // First 6 bills
      
      for (const bill of billsToMarkPaid) {
        const paymentResponse = await request(app)
          .post(`/api/bills/${bill.id}/mark-paid`)
          .send({ 
            paymentDate: '2024-02-15',
            notes: 'Paid via e2e test' 
          })
          .expect(200);

        expect(paymentResponse.body.message).toBe('Bill marked as paid successfully');
        expect(paymentResponse.body.status).toBe('paid');
      }

      // Step 5: Verify payment statistics
      const updatedStatsResponse = await request(app)
        .get(`/api/bills/${parentBill.id}/generated-stats`)
        .expect(200);

      expect(updatedStatsResponse.body.generatedBills.paidBills).toBe(6);
      expect(updatedStatsResponse.body.generatedBills.paidAmount).toBe(3000); // 6 * $500

      // Step 6: Update parent bill and cascade to children
      const updateResponse = await request(app)
        .put(`/api/bills/${parentBill.id}/update-generated`)
        .send({
          title: 'Updated Annual Insurance - Monthly Payments',
          vendor: 'Updated Insurance Corporation',
          notes: 'Updated via e2e test'
        })
        .expect(200);

      expect(updateResponse.body.message).toBe('Generated bills updated successfully');
      expect(updateResponse.body.billsUpdated).toBe(24);

      // Verify cascade update worked
      const updatedBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      updatedBills.forEach(bill => {
        expect(bill.title).toContain('Updated Annual Insurance');
        expect(bill.vendor).toBe('Updated Insurance Corporation');
        expect(bill.notes).toContain('Updated via e2e test');
      });

      // Step 7: Delete unpaid bills only
      const deleteResponse = await request(app)
        .delete(`/api/bills/${parentBill.id}/generated-bills`)
        .expect(200);

      expect(deleteResponse.body.message).toBe('Generated bills deleted successfully');
      expect(deleteResponse.body.billsDeleted).toBe(18); // 24 - 6 paid bills

      // Verify only paid bills remain
      const remainingBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      expect(remainingBills.length).toBe(6);
      remainingBills.forEach(bill => {
        expect(bill.status).toBe('paid');
      });

      console.warn('✅ Complete bill lifecycle test passed');
    });

    it('should handle complex split payment workflow', async () => {
      // Create bill with complex payment plan: 40% immediate, 35% in 3 months, 25% in 6 months
      const complexBill = {
        id: 'e2e-complex-split',
        buildingId: mockBuilding.id,
        billNumber: 'E2E-COMPLEX-001',
        title: 'Major Renovation - Three-Phase Payment',
        category: 'maintenance',
        vendor: 'Renovation Corp',
        paymentType: 'recurrent',
        schedulePayment: 'yearly',
        costs: ['20000.00', '17500.00', '12500.00'], // 40%, 35%, 25%
        totalAmount: '50000.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01', // 1 year
        createdBy: mockUser.id
      };

      global.mockBills = [complexBill];

      // Generate the split payment bills
      const generateResponse = await request(app)
        .post(`/api/bills/${complexBill.id}/generate-future`)
        .expect(200);

      expect(generateResponse.body.billsCreated).toBe(3); // 3 payment parts

      const generatedBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, complexBill.id))
        .orderBy(bills.startDate);

      // Verify split amounts
      expect(parseFloat(generatedBills[0].totalAmount)).toBe(20000); // 40%
      expect(parseFloat(generatedBills[1].totalAmount)).toBe(17500); // 35%
      expect(parseFloat(generatedBills[2].totalAmount)).toBe(12500); // 25%

      // Verify titles show part information
      expect(generatedBills[0].title).toContain('Part 1/3');
      expect(generatedBills[1].title).toContain('Part 2/3');
      expect(generatedBills[2].title).toContain('Part 3/3');

      // Verify payment timing (monthly intervals)
      const firstDate = new Date(generatedBills[0].startDate);
      const secondDate = new Date(generatedBills[1].startDate);
      const thirdDate = new Date(generatedBills[2].startDate);

      const months1to2 = (secondDate.getFullYear() - firstDate.getFullYear()) * 12 + 
                        (secondDate.getMonth() - firstDate.getMonth());
      const months2to3 = (thirdDate.getFullYear() - secondDate.getFullYear()) * 12 + 
                        (thirdDate.getMonth() - secondDate.getMonth());

      expect(months1to2).toBe(1);
      expect(months2to3).toBe(1);

      // Pay first installment
      await request(app)
        .post(`/api/bills/${generatedBills[0].id}/mark-paid`)
        .send({ paymentDate: '2024-01-15' })
        .expect(200);

      // Check payment progress
      const statsResponse = await request(app)
        .get(`/api/bills/${complexBill.id}/generated-stats`)
        .expect(200);

      expect(statsResponse.body.generatedBills.paidBills).toBe(1);
      expect(statsResponse.body.generatedBills.paidAmount).toBe(20000);
      expect(statsResponse.body.generatedBills.pendingBills).toBe(2);

      console.warn('✅ Complex split payment workflow test passed');
    });
  });

  describe('Multi-Year Projection Workflow', () => {
    it('should handle 25-year bill projection and management', async () => {
      const longTermBill = {
        id: 'e2e-25-year',
        buildingId: mockBuilding.id,
        billNumber: 'E2E-25YEAR-001',
        title: 'Long-term Maintenance Contract',
        category: 'maintenance',
        vendor: 'Long-term Services Inc',
        paymentType: 'recurrent',
        schedulePayment: 'quarterly',
        costs: ['1200.00'],
        totalAmount: '1200.00',
        startDate: '2024-01-01',
        endDate: null, // Ongoing - should project 25 years
        createdBy: mockUser.id
      };

      global.mockBills = [longTermBill];

      // Generate 25-year projection
      const startTime = Date.now();
      const generateResponse = await request(app)
        .post(`/api/bills/${longTermBill.id}/generate-future`)
        .expect(200);
      const duration = Date.now() - startTime;

      // Should generate ~100 bills (25 years * 4 quarters)
      expect(generateResponse.body.billsCreated).toBeGreaterThan(90);
      expect(generateResponse.body.billsCreated).toBeLessThan(110);
      expect(duration).toBeLessThan(10000); // Should complete within 10 seconds

      // Verify projection end date is approximately 25 years from start
      const projectionEnd = new Date(generateResponse.body.generatedUntil);
      const startDate = new Date('2024-01-01');
      const yearsDiff = projectionEnd.getFullYear() - startDate.getFullYear();
      expect(yearsDiff).toBe(25);

      // Verify bills were actually created
      const generatedBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, longTermBill.id));

      expect(generatedBills.length).toBe(generateResponse.body.billsCreated);

      // Sample verification - check first and last bills
      const sortedBills = generatedBills.sort((a, b) => 
        new Date(a.startDate).getTime() - new Date(b.startDate).getTime()
      );

      expect(sortedBills[0].startDate).toBe('2024-01-01');
      expect(parseFloat(sortedBills[0].totalAmount)).toBe(1200);

      const lastBill = sortedBills[sortedBills.length - 1];
      const lastDate = new Date(lastBill.startDate);
      expect(lastDate.getFullYear()).toBe(2048); // Should be in 2048

      // Test partial payment and statistics
      const firstQuarterBills = sortedBills.slice(0, 4); // First year
      for (const bill of firstQuarterBills) {
        await request(app)
          .post(`/api/bills/${bill.id}/mark-paid`)
          .send({ paymentDate: '2024-03-15' })
          .expect(200);
      }

      const statsResponse = await request(app)
        .get(`/api/bills/${longTermBill.id}/generated-stats`)
        .expect(200);

      expect(statsResponse.body.generatedBills.paidBills).toBe(4);
      expect(statsResponse.body.generatedBills.paidAmount).toBe(4800); // 4 * $1200

      console.warn('✅ 25-year projection workflow test passed');
    });

    it('should handle regeneration after parent changes', async () => {
      const modifiableBill = {
        id: 'e2e-modifiable',
        buildingId: mockBuilding.id,
        billNumber: 'E2E-MODIFIABLE-001',
        title: 'Modifiable Service Contract',
        category: 'cleaning',
        vendor: 'Original Cleaning Co',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['300.00'],
        totalAmount: '300.00',
        startDate: '2024-01-01',
        endDate: '2024-07-01', // 6 months
        createdBy: mockUser.id
      };

      global.mockBills = [modifiableBill];

      // Initial generation
      await request(app)
        .post(`/api/bills/${modifiableBill.id}/generate-future`)
        .expect(200);

      const generatedBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, modifiableBill.id));

      expect(generatedBills.length).toBe(6);
      expect(generatedBills[0].vendor).toBe('Original Cleaning Co');

      // Mark some bills as paid
      await request(app)
        .post(`/api/bills/${generatedBills[0].id}/mark-paid`)
        .expect(200);

      await request(app)
        .post(`/api/bills/${generatedBills[1].id}/mark-paid`)
        .expect(200);

      // Update parent and cascade
      await request(app)
        .put(`/api/bills/${modifiableBill.id}/update-generated`)
        .send({
          vendor: 'Updated Cleaning Corp',
          notes: 'Service provider changed'
        })
        .expect(200);

      // Verify paid bills kept their status but got updated info
      const updatedBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, modifiableBill.id))
        .orderBy(bills.startDate);

      expect(updatedBills[0].vendor).toBe('Updated Cleaning Corp');
      expect(updatedBills[0].status).toBe('paid'); // Status preserved
      expect(updatedBills[0].notes).toContain('Service provider changed');

      // Regenerate with new parameters
      const modifiedBill = {
        ...modifiableBill,
        costs: ['400.00'], // Increased cost
        totalAmount: '400.00',
        endDate: '2024-09-01' // Extended to 8 months
      };

      global.mockBills = [modifiedBill];

      await request(app)
        .post(`/api/bills/${modifiableBill.id}/generate-future`)
        .expect(200);

      const regeneratedBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, modifiableBill.id));

      expect(regeneratedBills.length).toBe(8); // Extended to 8 months
      
      // Verify new amount in unpaid bills
      const unpaidBills = regeneratedBills.filter(bill => bill.status !== 'paid');
      unpaidBills.forEach(bill => {
        expect(parseFloat(bill.totalAmount)).toBe(400);
      });

      console.warn('✅ Regeneration after parent changes test passed');
    });
  });

  describe('Error Handling and Edge Cases', () => {
    it('should handle API errors gracefully', async () => {
      // Test non-existent bill
      const response404 = await request(app)
        .post('/api/bills/non-existent-bill/generate-future')
        .expect(404);

      expect(response404.body.message).toBe('Bill not found');

      // Test invalid bill type for generation
      const uniqueBill = {
        id: 'unique-bill-test',
        buildingId: mockBuilding.id,
        paymentType: 'unique', // Cannot generate future instances
        title: 'Unique Bill'
      };

      global.mockBills = [uniqueBill];

      const response400 = await request(app)
        .post('/api/bills/unique-bill-test/generate-future')
        .expect(400);

      expect(response400.body.message).toBe('Only recurrent bills can generate future instances');

      // Test marking non-existent bill as paid
      const paymentResponse404 = await request(app)
        .post('/api/bills/non-existent-bill/mark-paid')
        .expect(404);

      expect(paymentResponse404.body.message).toBe('Bill not found');

      console.warn('✅ Error handling test passed');
    });

    it('should handle concurrent operations safely', async () => {
      const concurrentBill = {
        id: 'concurrent-test-bill',
        buildingId: mockBuilding.id,
        billNumber: 'CONCURRENT-001',
        title: 'Concurrent Operations Test',
        category: 'utilities',
        vendor: 'Utility Corp',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['200.00'],
        totalAmount: '200.00',
        startDate: '2024-01-01',
        endDate: '2024-06-01', // 5 months
        createdBy: mockUser.id
      };

      global.mockBills = [concurrentBill];

      // Make concurrent requests
      const [response1, response2, response3] = await Promise.all([
        request(app).post(`/api/bills/${concurrentBill.id}/generate-future`),
        request(app).get(`/api/bills/${concurrentBill.id}/generated-stats`),
        request(app).post(`/api/bills/${concurrentBill.id}/generate-future`)
      ]);

      expect(response1.status).toBe(200);
      expect(response2.status).toBe(200);
      expect(response3.status).toBe(200);

      // Verify final state is consistent
      const finalBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, concurrentBill.id));

      expect(finalBills.length).toBe(5); // Should have 5 bills, not duplicates

      console.warn('✅ Concurrent operations test passed');
    });

    it('should handle large dataset operations efficiently', async () => {
      const largeBill = {
        id: 'large-dataset-bill',
        buildingId: mockBuilding.id,
        billNumber: 'LARGE-001',
        title: 'Large Dataset Test - Weekly Service',
        category: 'cleaning',
        vendor: 'Weekly Service Corp',
        paymentType: 'recurrent',
        schedulePayment: 'weekly',
        costs: ['50.00'],
        totalAmount: '50.00',
        startDate: '2024-01-01',
        endDate: '2026-01-01', // 2 years of weekly bills
        createdBy: mockUser.id
      };

      global.mockBills = [largeBill];

      // Generate large number of bills
      const startTime = Date.now();
      const generateResponse = await request(app)
        .post(`/api/bills/${largeBill.id}/generate-future`)
        .expect(200);
      const duration = Date.now() - startTime;

      // Should generate ~104 bills (2 years * 52 weeks)
      expect(generateResponse.body.billsCreated).toBeGreaterThan(100);
      expect(generateResponse.body.billsCreated).toBeLessThan(110);
      expect(duration).toBeLessThan(15000); // Should complete within 15 seconds

      // Test bulk payment operations
      const generatedBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, largeBill.id))
        .limit(20); // Mark first 20 as paid

      const paymentStartTime = Date.now();
      
      // Use Promise.all for concurrent payment processing
      await Promise.all(
        generatedBills.map(bill =>
          request(app)
            .post(`/api/bills/${bill.id}/mark-paid`)
            .send({ paymentDate: '2024-02-15' })
        )
      );

      const paymentDuration = Date.now() - paymentStartTime;
      expect(paymentDuration).toBeLessThan(10000); // Should complete within 10 seconds

      // Verify statistics
      const statsResponse = await request(app)
        .get(`/api/bills/${largeBill.id}/generated-stats`)
        .expect(200);

      expect(statsResponse.body.generatedBills.paidBills).toBe(20);
      expect(statsResponse.body.generatedBills.paidAmount).toBe(1000); // 20 * $50

      console.warn('✅ Large dataset operations test passed');
    });
  });

  describe('Real-World Scenario Simulation', () => {
    it('should simulate property management company workflow', async () => {
      // Scenario: Property management company managing multiple recurring bills
      const bills = [
        {
          id: 'scenario-insurance',
          buildingId: mockBuilding.id,
          billNumber: 'INSURANCE-2024-001',
          title: 'Building Insurance Premium',
          category: 'insurance',
          vendor: 'Quebec Insurance Corp',
          paymentType: 'recurrent',
          schedulePayment: 'yearly',
          costs: ['8000.00', '4000.00'], // 66% upfront, 33% after 6 months
          totalAmount: '12000.00',
          startDate: '2024-01-01',
          endDate: '2027-01-01', // 3 years
          createdBy: mockUser.id
        },
        {
          id: 'scenario-maintenance',
          buildingId: mockBuilding.id,
          billNumber: 'MAINTENANCE-2024-001',
          title: 'Monthly Maintenance Contract',
          category: 'maintenance',
          vendor: 'Montreal Maintenance Services',
          paymentType: 'recurrent',
          schedulePayment: 'monthly',
          costs: ['800.00'],
          totalAmount: '800.00',
          startDate: '2024-01-01',
          endDate: '2025-01-01', // 1 year
          createdBy: mockUser.id
        },
        {
          id: 'scenario-utilities',
          buildingId: mockBuilding.id,
          billNumber: 'UTILITIES-2024-001',
          title: 'Quarterly Utilities',
          category: 'utilities',
          vendor: 'Hydro-Quebec',
          paymentType: 'recurrent',
          schedulePayment: 'quarterly',
          costs: ['1500.00', '1200.00', '900.00', '1200.00'], // Seasonal variation
          totalAmount: '4800.00',
          startDate: '2024-01-01',
          endDate: '2025-01-01', // 1 year
          createdBy: mockUser.id
        }
      ];

      global.mockBills = bills;

      // Generate all bills
      const results = await Promise.all(bills.map(bill =>
        request(app)
          .post(`/api/bills/${bill.id}/generate-future`)
          .expect(200)
      ));

      expect(results[0].body.billsCreated).toBe(6); // Insurance: 3 years * 2 payments
      expect(results[1].body.billsCreated).toBe(12); // Maintenance: 12 months
      expect(results[2].body.billsCreated).toBe(16); // Utilities: 4 quarters * 4 payments

      // Simulate property manager workflow
      
      // 1. Check overall statistics
      const allStats = await Promise.all(bills.map(bill =>
        request(app)
          .get(`/api/bills/${bill.id}/generated-stats`)
          .expect(200)
      ));

      let totalBills = 0;
      let totalAmount = 0;
      
      allStats.forEach(stats => {
        totalBills += stats.body.generatedBills.totalGenerated;
        totalAmount += stats.body.generatedBills.totalAmount;
      });

      expect(totalBills).toBe(34); // 6 + 12 + 16
      expect(totalAmount).toBe(67200); // Insurance: 36k, Maintenance: 9.6k, Utilities: 19.2k

      // 2. Simulate monthly payment processing
      const allGeneratedBills = await db
        .select()
        .from(bills)
        .where(eq(bills.buildingId, mockBuilding.id))
        .orderBy(bills.startDate);

      // Pay all bills due in January 2024
      const januaryBills = allGeneratedBills.filter(bill =>
        bill.startDate.startsWith('2024-01')
      );

      await Promise.all(
        januaryBills.map(bill =>
          request(app)
            .post(`/api/bills/${bill.id}/mark-paid`)
            .send({ 
              paymentDate: '2024-01-31',
              notes: 'Paid - January 2024 batch'
            })
        )
      );

      // 3. Update maintenance contract vendor
      await request(app)
        .put('/api/bills/scenario-maintenance/update-generated')
        .send({
          vendor: 'Updated Montreal Maintenance Services Inc',
          notes: 'Vendor name change - legal update'
        })
        .expect(200);

      // 4. Verify all operations completed successfully
      const finalStats = await Promise.all(bills.map(bill =>
        request(app)
          .get(`/api/bills/${bill.id}/generated-stats`)
          .expect(200)
      ));

      const totalPaidBills = finalStats.reduce((sum, stats) => 
        sum + stats.body.generatedBills.paidBills, 0
      );

      expect(totalPaidBills).toBe(januaryBills.length);

      // 5. Simulate year-end cleanup - delete future unpaid bills
      await Promise.all(bills.map(bill =>
        request(app)
          .delete(`/api/bills/${bill.id}/generated-bills`)
          .query({ deleteAllFuture: 'false' })
          .expect(200)
      ));

      console.warn('✅ Property management company workflow simulation passed');
    });
  });

  describe('Performance and Monitoring', () => {
    it('should maintain performance standards under load', async () => {
      const performanceBill = {
        id: 'performance-test-bill',
        buildingId: mockBuilding.id,
        billNumber: 'PERF-001',
        title: 'Performance Test Bill',
        category: 'utilities',
        vendor: 'Performance Test Corp',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['100.00'],
        totalAmount: '100.00',
        startDate: '2024-01-01',
        endDate: '2029-01-01', // 5 years
        createdBy: mockUser.id
      };

      global.mockBills = [performanceBill];

      // Measure generation performance
      const genStart = Date.now();
      await request(app)
        .post(`/api/bills/${performanceBill.id}/generate-future`)
        .expect(200);
      const genDuration = Date.now() - genStart;

      expect(genDuration).toBeLessThan(5000); // Generation within 5 seconds

      // Measure statistics query performance
      const statsStart = Date.now();
      await request(app)
        .get(`/api/bills/${performanceBill.id}/generated-stats`)
        .expect(200);
      const statsDuration = Date.now() - statsStart;

      expect(statsDuration).toBeLessThan(1000); // Stats within 1 second

      // Measure update performance
      const updateStart = Date.now();
      await request(app)
        .put(`/api/bills/${performanceBill.id}/update-generated`)
        .send({ notes: 'Performance test update' })
        .expect(200);
      const updateDuration = Date.now() - updateStart;

      expect(updateDuration).toBeLessThan(3000); // Update within 3 seconds

      // Memory usage check
      const memoryBefore = process.memoryUsage().heapUsed;
      
      // Perform multiple operations
      for (let i = 0; i < 5; i++) {
        await request(app)
          .get(`/api/bills/${performanceBill.id}/generated-stats`)
          .expect(200);
      }

      const memoryAfter = process.memoryUsage().heapUsed;
      const memoryIncrease = memoryAfter - memoryBefore;

      // Memory increase should be reasonable (less than 10MB)
      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);

      console.warn('✅ Performance and monitoring test passed');
    });
  });
});