import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { db } from '../../server/db';
import { bills } from '../../shared/schemas/financial';
import { billGenerationService } from '../../server/services/bill-generation-service';
import { eq, and, isNull } from 'drizzle-orm';

/**
 * Comprehensive Integration Tests for Bill Relationships
 * Tests parent-child bill relationships and cascade operations including:
 * - Parent bill to auto-generated bills relationships
 * - Cascade updates from parent to children
 * - Cascade deletions with options
 * - Orphaned bill handling
 * - Complex relationship hierarchies
 * - Relationship data integrity.
 */

describe('Bill Relationships Integration Tests', () => {
  const mockBuilding = { id: 'building-relationships', organizationId: 'org-relationships' };
  const mockUser = { id: 'user-relationships' };

  beforeEach(async () => {
    // Clean up all test data
    await db.delete(bills).where(eq(bills.buildingId, mockBuilding.id));
  });

  afterEach(async () => {
    await db.delete(bills).where(eq(bills.buildingId, mockBuilding.id));
  });

  describe('Parent-Child Relationship Creation', () => {
    it('should create proper parent-child relationships', async () => {
      const parentBill = {
        id: 'parent-relationship-1',
        buildingId: mockBuilding.id,
        billNumber: 'PARENT-REL-001',
        title: 'Parent Bill for Relationships',
        description: 'Test parent bill',
        category: 'maintenance',
        vendor: 'Test Vendor',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        scheduleCustom: null,
        costs: ['1000.00'],
        totalAmount: '1000.00',
        startDate: '2024-01-01',
        endDate: '2024-06-30', // 6 months
        status: 'active',
        autoGenerated: false,
        reference: null,
        createdBy: mockUser.id,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // Generate child bills
      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);
      expect(result.billsCreated).toBe(6);

      // Verify parent bill exists and has correct properties
      const [parentInDb] = await db
        .select()
        .from(bills)
        .where(eq(bills.id, parentBill.id));

      expect(parentInDb).toBeUndefined(); // Parent is not in DB in this test setup

      // Verify child bills have correct relationships
      const childBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      expect(childBills.length).toBe(6);
      
      childBills.forEach(child => {
        expect(child.autoGenerated).toBe(true);
        expect(child.reference).toBe(parentBill.id);
        expect(child.paymentType).toBe('unique'); // Auto-generated bills are unique
        expect(child.buildingId).toBe(parentBill.buildingId);
        expect(child.category).toBe(parentBill.category);
        expect(child.vendor).toBe(parentBill.vendor);
      });
    });

    it('should handle multiple parent bills with different children', async () => {
      const parentBill1 = {
        id: 'parent-multi-1',
        buildingId: mockBuilding.id,
        billNumber: 'PARENT-MULTI-001',
        title: 'First Parent Bill',
        category: 'insurance',
        vendor: 'Insurance Co',
        paymentType: 'recurrent',
        schedulePayment: 'quarterly',
        costs: ['2500.00'],
        totalAmount: '2500.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01', // 4 quarters
        createdBy: mockUser.id
      };

      const parentBill2 = {
        id: 'parent-multi-2',
        buildingId: mockBuilding.id,
        billNumber: 'PARENT-MULTI-002',
        title: 'Second Parent Bill',
        category: 'utilities',
        vendor: 'Utility Co',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['800.00'],
        totalAmount: '800.00',
        startDate: '2024-01-01',
        endDate: '2024-07-01', // 6 months
        createdBy: mockUser.id
      };

      // Generate children for both parents
      const result1 = await billGenerationService.generateFutureBillInstances(parentBill1 as any);
      const result2 = await billGenerationService.generateFutureBillInstances(parentBill2 as any);

      expect(result1.billsCreated).toBe(4); // Quarterly
      expect(result2.billsCreated).toBe(6); // Monthly

      // Verify children are properly separated by parent
      const children1 = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill1.id));

      const children2 = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill2.id));

      expect(children1.length).toBe(4);
      expect(children2.length).toBe(6);

      // Verify children have correct parent-specific properties
      children1.forEach(child => {
        expect(child.category).toBe('insurance');
        expect(child.vendor).toBe('Insurance Co');
        expect(parseFloat(child.totalAmount)).toBe(2500);
      });

      children2.forEach(child => {
        expect(child.category).toBe('utilities');
        expect(child.vendor).toBe('Utility Co');
        expect(parseFloat(child.totalAmount)).toBe(800);
      });
    });

    it('should generate unique bill numbers for child bills', async () => {
      const parentBill = {
        id: 'parent-unique-numbers',
        buildingId: mockBuilding.id,
        billNumber: 'UNIQUE-NUMS-001',
        title: 'Parent for Unique Numbers',
        category: 'maintenance',
        vendor: 'Maintenance Co',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['500.00'],
        totalAmount: '500.00',
        startDate: '2024-01-01',
        endDate: '2024-04-01', // 3 months
        createdBy: mockUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const childBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id))
        .orderBy(bills.startDate);

      // Verify unique bill numbers follow pattern: PARENT-YYYY-MM
      expect(childBills[0].billNumber).toBe('UNIQUE-NUMS-001-2024-01');
      expect(childBills[1].billNumber).toBe('UNIQUE-NUMS-001-2024-02');
      expect(childBills[2].billNumber).toBe('UNIQUE-NUMS-001-2024-03');

      // Verify all bill numbers are unique
      const billNumbers = childBills.map(bill => bill.billNumber);
      const uniqueBillNumbers = new Set(billNumbers);
      expect(uniqueBillNumbers.size).toBe(billNumbers.length);
    });

    it('should generate descriptive titles for child bills', async () => {
      const parentBill = {
        id: 'parent-titles',
        buildingId: mockBuilding.id,
        billNumber: 'TITLES-001',
        title: 'Monthly Cleaning Service',
        category: 'cleaning',
        vendor: 'Clean Corp',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['300.00'],
        totalAmount: '300.00',
        startDate: '2024-03-01',
        endDate: '2024-06-01', // 3 months
        createdBy: mockUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const childBills = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id))
        .orderBy(bills.startDate);

      // Verify descriptive titles with month/year
      expect(childBills[0].title).toBe('Monthly Cleaning Service - March 2024');
      expect(childBills[1].title).toBe('Monthly Cleaning Service - April 2024');
      expect(childBills[2].title).toBe('Monthly Cleaning Service - May 2024');
    });
  });

  describe('Cascade Update Operations', () => {
    it('should cascade updates from parent to all children', async () => {
      const parentBill = {
        id: 'parent-cascade-update',
        buildingId: mockBuilding.id,
        billNumber: 'CASCADE-UPDATE-001',
        title: 'Original Title',
        category: 'maintenance',
        vendor: 'Original Vendor',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['400.00'],
        totalAmount: '400.00',
        startDate: '2024-01-01',
        endDate: '2024-05-01', // 4 months
        createdBy: mockUser.id
      };

      // Generate initial children
      await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Verify initial state
      const initialChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      expect(initialChildren.length).toBe(4);
      initialChildren.forEach(child => {
        expect(child.title).toContain('Original Title');
        expect(child.category).toBe('maintenance');
        expect(child.vendor).toBe('Original Vendor');
      });

      // Perform cascade update
      const updates = {
        title: 'Updated Title',
        category: 'utilities',
        vendor: 'New Vendor Corp',
        notes: 'Updated via cascade operation'
      };

      const updateResult = await billGenerationService.updateGeneratedBillsFromParent(
        parentBill.id,
        updates
      );

      expect(updateResult.billsUpdated).toBe(4);

      // Verify all children were updated
      const updatedChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      updatedChildren.forEach(child => {
        expect(child.title).toContain('Updated Title');
        expect(child.category).toBe('utilities');
        expect(child.vendor).toBe('New Vendor Corp');
        expect(child.notes).toContain('Updated via cascade operation');
      });
    });

    it('should preserve child-specific information during cascade updates', async () => {
      const parentBill = {
        id: 'parent-preserve-child-info',
        buildingId: mockBuilding.id,
        billNumber: 'PRESERVE-001',
        title: 'Quarterly Service',
        category: 'professional_services',
        vendor: 'Service Provider',
        paymentType: 'recurrent',
        schedulePayment: 'quarterly',
        costs: ['1500.00', '1200.00'], // Split payment
        totalAmount: '2700.00',
        startDate: '2024-01-01',
        endDate: '2024-07-01', // 2 quarters
        createdBy: mockUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const initialChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id))
        .orderBy(bills.startDate);

      // Verify initial part numbering
      expect(initialChildren[0].title).toContain('Part 1/2');
      expect(initialChildren[1].title).toContain('Part 2/2');
      expect(initialChildren[2].title).toContain('Part 1/2');
      expect(initialChildren[3].title).toContain('Part 2/2');

      // Update parent
      await billGenerationService.updateGeneratedBillsFromParent(parentBill.id, {
        title: 'Updated Quarterly Service'
      });

      const updatedChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id))
        .orderBy(bills.startDate);

      // Verify part information is preserved
      expect(updatedChildren[0].title).toContain('Updated Quarterly Service');
      expect(updatedChildren[0].title).toContain('Part 1/2');
      expect(updatedChildren[1].title).toContain('Part 2/2');
      expect(updatedChildren[2].title).toContain('Part 1/2');
      expect(updatedChildren[3].title).toContain('Part 2/2');

      // Verify amounts remain unchanged
      expect(parseFloat(updatedChildren[0].totalAmount)).toBe(1500);
      expect(parseFloat(updatedChildren[1].totalAmount)).toBe(1200);
    });

    it('should handle partial updates without affecting unchanged fields', async () => {
      const parentBill = {
        id: 'parent-partial-update',
        buildingId: mockBuilding.id,
        billNumber: 'PARTIAL-001',
        title: 'Partial Update Test',
        category: 'maintenance',
        vendor: 'Original Vendor',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['600.00'],
        totalAmount: '600.00',
        startDate: '2024-01-01',
        endDate: '2024-04-01', // 3 months
        createdBy: mockUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Update only vendor
      await billGenerationService.updateGeneratedBillsFromParent(parentBill.id, {
        vendor: 'Updated Vendor Only'
      });

      const updatedChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      updatedChildren.forEach(child => {
        // Vendor should be updated
        expect(child.vendor).toBe('Updated Vendor Only');
        
        // Other fields should remain unchanged
        expect(child.title).toContain('Partial Update Test');
        expect(child.category).toBe('maintenance');
        expect(parseFloat(child.totalAmount)).toBe(600);
      });
    });
  });

  describe('Cascade Delete Operations', () => {
    it('should delete only unpaid bills by default', async () => {
      const parentBill = {
        id: 'parent-delete-unpaid',
        buildingId: mockBuilding.id,
        billNumber: 'DELETE-UNPAID-001',
        title: 'Delete Unpaid Test',
        category: 'utilities',
        vendor: 'Utility Co',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['350.00'],
        totalAmount: '350.00',
        startDate: '2024-01-01',
        endDate: '2024-06-01', // 5 months
        createdBy: mockUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const allChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      expect(allChildren.length).toBe(5);

      // Mark some bills as paid
      await billGenerationService.markBillAsPaid(allChildren[0].id);
      await billGenerationService.markBillAsPaid(allChildren[1].id);

      // Delete unpaid bills only
      const deleteResult = await billGenerationService.deleteGeneratedBills(parentBill.id, false);
      expect(deleteResult.billsDeleted).toBe(3); // 3 unpaid bills deleted

      // Verify paid bills remain
      const remainingChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      expect(remainingChildren.length).toBe(2);
      remainingChildren.forEach(child => {
        expect(child.status).toBe('paid');
      });
    });

    it('should delete all future bills when deleteAllFuture is true', async () => {
      const today = new Date();
      const futureDate = new Date(today);
      futureDate.setMonth(futureDate.getMonth() + 6);

      const parentBill = {
        id: 'parent-delete-all-future',
        buildingId: mockBuilding.id,
        billNumber: 'DELETE-ALL-FUTURE-001',
        title: 'Delete All Future Test',
        category: 'maintenance',
        vendor: 'Maintenance Co',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['200.00'],
        totalAmount: '200.00',
        startDate: futureDate.toISOString().split('T')[0], // Start in future
        endDate: null, // Ongoing
        createdBy: mockUser.id
      };

      const result = await billGenerationService.generateFutureBillInstances(parentBill as any);
      expect(result.billsCreated).toBeGreaterThan(200); // Many future bills

      const allChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      // Mark some as paid
      for (let i = 0; i < 5; i++) {
        await billGenerationService.markBillAsPaid(allChildren[i].id);
      }

      // Delete all future bills
      const deleteResult = await billGenerationService.deleteGeneratedBills(parentBill.id, true);
      expect(deleteResult.billsDeleted).toBe(result.billsCreated); // All bills deleted

      // Verify no bills remain
      const remainingChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      expect(remainingChildren.length).toBe(0);
    });

    it('should handle deletion of bills with no generated children', async () => {
      const parentBillId = 'parent-no-children';

      // Try to delete children of non-existent parent
      const deleteResult = await billGenerationService.deleteGeneratedBills(parentBillId, false);
      expect(deleteResult.billsDeleted).toBe(0);
    });

    it('should preserve bills from other parents during deletion', async () => {
      const parentBill1 = {
        id: 'parent-preserve-1',
        buildingId: mockBuilding.id,
        billNumber: 'PRESERVE-001',
        title: 'First Parent',
        category: 'insurance',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['100.00'],
        totalAmount: '100.00',
        startDate: '2024-01-01',
        endDate: '2024-04-01',
        createdBy: mockUser.id
      };

      const parentBill2 = {
        id: 'parent-preserve-2',
        buildingId: mockBuilding.id,
        billNumber: 'PRESERVE-002',
        title: 'Second Parent',
        category: 'utilities',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['200.00'],
        totalAmount: '200.00',
        startDate: '2024-01-01',
        endDate: '2024-04-01',
        createdBy: mockUser.id
      };

      // Generate children for both parents
      await billGenerationService.generateFutureBillInstances(parentBill1 as any);
      await billGenerationService.generateFutureBillInstances(parentBill2 as any);

      const children1Before = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill1.id));

      const children2Before = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill2.id));

      expect(children1Before.length).toBe(3);
      expect(children2Before.length).toBe(3);

      // Delete children of first parent only
      await billGenerationService.deleteGeneratedBills(parentBill1.id, true);

      const children1After = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill1.id));

      const children2After = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill2.id));

      // First parent's children should be deleted
      expect(children1After.length).toBe(0);

      // Second parent's children should remain
      expect(children2After.length).toBe(3);
      children2After.forEach(child => {
        expect(child.reference).toBe(parentBill2.id);
        expect(child.title).toContain('Second Parent');
      });
    });
  });

  describe('Relationship Data Integrity', () => {
    it('should maintain referential integrity with foreign key constraints', async () => {
      const parentBill = {
        id: 'parent-integrity',
        buildingId: mockBuilding.id,
        billNumber: 'INTEGRITY-001',
        title: 'Integrity Test Parent',
        category: 'maintenance',
        vendor: 'Test Vendor',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['250.00'],
        totalAmount: '250.00',
        startDate: '2024-01-01',
        endDate: '2024-04-01', // 3 months
        createdBy: mockUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const children = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      expect(children.length).toBe(3);

      // Verify all children reference the correct parent
      children.forEach(child => {
        expect(child.reference).toBe(parentBill.id);
        expect(child.autoGenerated).toBe(true);
      });

      // Verify we can query children by parent reference
      const childrenByReference = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.reference, parentBill.id),
          eq(bills.autoGenerated, true)
        ));

      expect(childrenByReference.length).toBe(3);
    });

    it('should handle orphaned bills gracefully', async () => {
      // Create some bills with invalid parent references
      const orphanedBill = {
        buildingId: mockBuilding.id,
        billNumber: 'ORPHANED-001',
        title: 'Orphaned Bill',
        description: 'Bill with non-existent parent',
        category: 'other',
        vendor: 'Test Vendor',
        paymentType: 'unique',
        schedulePayment: null,
        scheduleCustom: null,
        costs: ['100.00'],
        totalAmount: '100.00',
        startDate: '2024-01-01',
        status: 'draft',
        autoGenerated: true,
        reference: 'non-existent-parent-id',
        createdBy: mockUser.id
      };

      const [insertedOrphan] = await db.insert(bills).values(orphanedBill).returning();

      // Verify orphaned bill exists
      const orphans = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.autoGenerated, true),
          eq(bills.reference, 'non-existent-parent-id')
        ));

      expect(orphans.length).toBe(1);
      expect(orphans[0].reference).toBe('non-existent-parent-id');

      // Verify we can query orphaned bills
      const allAutoBills = await db
        .select()
        .from(bills)
        .where(eq(bills.autoGenerated, true));

      const orphanedBills = allAutoBills.filter(bill => 
        bill.reference === 'non-existent-parent-id'
      );

      expect(orphanedBills.length).toBe(1);
    });

    it('should prevent circular references', async () => {
      // This test verifies the schema prevents circular references
      // In practice, the business logic should prevent this
      
      const bill1 = {
        id: 'bill-circular-1',
        buildingId: mockBuilding.id,
        billNumber: 'CIRCULAR-001',
        title: 'Circular Test 1',
        category: 'other',
        vendor: 'Test',
        paymentType: 'unique',
        costs: ['100.00'],
        totalAmount: '100.00',
        startDate: '2024-01-01',
        status: 'draft',
        autoGenerated: false,
        reference: null,
        createdBy: mockUser.id
      };

      const [inserted1] = await db.insert(bills).values(bill1).returning();

      // Try to create a bill that references itself
      const selfReferencingBill = {
        ...bill1,
        id: 'bill-self-ref',
        billNumber: 'SELF-REF-001',
        autoGenerated: true,
        reference: 'bill-self-ref' // Self-reference
      };

      // This should either fail or be handled gracefully
      // The exact behavior depends on database constraints
      try {
        await db.insert(bills).values(selfReferencingBill);
        
        // If it succeeds, verify the reference exists
        const [selfRef] = await db
          .select()
          .from(bills)
          .where(eq(bills.id, 'bill-self-ref'));
        
        if (selfRef) {
          expect(selfRef.reference).toBe('bill-self-ref');
        }
      } catch (__error) {
        // If it fails due to constraints, that's also acceptable
        expect(error).toBeDefined();
      }
    });
  });

  describe('Complex Relationship Scenarios', () => {
    it('should handle bills with mixed auto-generated and manual flags', async () => {
      const parentBill = {
        id: 'parent-mixed',
        buildingId: mockBuilding.id,
        billNumber: 'MIXED-001',
        title: 'Mixed Bills Parent',
        category: 'maintenance',
        vendor: 'Mixed Vendor',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['150.00'],
        totalAmount: '150.00',
        startDate: '2024-01-01',
        endDate: '2024-04-01', // 3 months
        createdBy: mockUser.id
      };

      // Generate auto bills
      await billGenerationService.generateFutureBillInstances(parentBill as any);

      // Also create a manual bill in the same building
      const manualBill = {
        buildingId: mockBuilding.id,
        billNumber: 'MANUAL-001',
        title: 'Manual Bill',
        category: 'utilities',
        vendor: 'Manual Vendor',
        paymentType: 'unique',
        costs: ['500.00'],
        totalAmount: '500.00',
        startDate: '2024-02-01',
        status: 'draft',
        autoGenerated: false,
        reference: null,
        createdBy: mockUser.id
      };

      await db.insert(bills).values(manualBill);

      // Verify counts
      const autoGeneratedBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.buildingId, mockBuilding.id),
          eq(bills.autoGenerated, true)
        ));

      const manualBills = await db
        .select()
        .from(bills)
        .where(and(
          eq(bills.buildingId, mockBuilding.id),
          eq(bills.autoGenerated, false)
        ));

      expect(autoGeneratedBills.length).toBe(3);
      expect(manualBills.length).toBe(1);

      // Verify they don't interfere with each other
      expect(autoGeneratedBills[0].reference).toBe(parentBill.id);
      expect(manualBills[0].reference).toBeNull();
    });

    it('should handle regeneration of children after parent changes', async () => {
      const parentBill = {
        id: 'parent-regeneration',
        buildingId: mockBuilding.id,
        billNumber: 'REGEN-001',
        title: 'Regeneration Test',
        category: 'maintenance',
        vendor: 'Original Vendor',
        paymentType: 'recurrent',
        schedulePayment: 'monthly',
        costs: ['300.00'],
        totalAmount: '300.00',
        startDate: '2024-01-01',
        endDate: '2024-05-01', // 4 months
        createdBy: mockUser.id
      };

      // Initial generation
      const firstResult = await billGenerationService.generateFutureBillInstances(parentBill as any);
      expect(firstResult.billsCreated).toBe(4);

      const firstChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      expect(firstChildren.length).toBe(4);
      expect(firstChildren[0].vendor).toBe('Original Vendor');

      // Regenerate (should clean up and recreate)
      const modifiedParent = {
        ...parentBill,
        vendor: 'Modified Vendor',
        costs: ['400.00'], // Changed amount
        totalAmount: '400.00'
      };

      const secondResult = await billGenerationService.generateFutureBillInstances(modifiedParent as any);
      expect(secondResult.billsCreated).toBe(4);

      const secondChildren = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id));

      // Should still have 4 children, but updated
      expect(secondChildren.length).toBe(4);
      secondChildren.forEach(child => {
        expect(child.vendor).toBe('Modified Vendor');
        expect(parseFloat(child.totalAmount)).toBe(400);
      });
    });

    it('should handle statistics for complex parent-child relationships', async () => {
      const parentBill = {
        id: 'parent-stats-complex',
        buildingId: mockBuilding.id,
        billNumber: 'STATS-COMPLEX-001',
        title: 'Complex Stats Parent',
        category: 'insurance',
        vendor: 'Insurance Co',
        paymentType: 'recurrent',
        schedulePayment: 'quarterly',
        costs: ['1000.00', '800.00'], // Split payment
        totalAmount: '1800.00',
        startDate: '2024-01-01',
        endDate: '2025-01-01', // 1 year = 4 quarters * 2 payments = 8 bills
        createdBy: mockUser.id
      };

      await billGenerationService.generateFutureBillInstances(parentBill as any);

      const children = await db
        .select()
        .from(bills)
        .where(eq(bills.reference, parentBill.id))
        .orderBy(bills.startDate);

      expect(children.length).toBe(8);

      // Mark some bills as paid with different patterns
      await billGenerationService.markBillAsPaid(children[0].id); // Q1 Part 1
      await billGenerationService.markBillAsPaid(children[1].id); // Q1 Part 2
      await billGenerationService.markBillAsPaid(children[2].id); // Q2 Part 1
      // Leave Q2 Part 2, Q3, Q4 unpaid

      const stats = await billGenerationService.getGeneratedBillsStats(parentBill.id);

      expect(stats.totalGenerated).toBe(8);
      expect(stats.paidBills).toBe(3);
      expect(stats.pendingBills).toBeGreaterThan(0);
      expect(stats.totalAmount).toBe(14400); // 8 bills total: 4 * 1000 + 4 * 800
      expect(stats.paidAmount).toBe(2800); // 2 * 1000 + 1 * 800

      // Verify calculation accuracy
      const expectedTotal = 4 * 1000 + 4 * 800;
      expect(stats.totalAmount).toBe(expectedTotal);
    });
  });
});